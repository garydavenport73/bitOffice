<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><style>html {
    box-sizing: border-box;
    font-size: 16px;
}

*,
*:before,
*:after {
    box-sizing: inherit;
}

body,
h1,
h2,
h3,
h4,
h5,
h6,
p,
ol,
ul {
    margin: 0;
    padding: 0;
    font-weight: normal;
}

ol,
ul {
    list-style: none;
}

img {
    max-width: 100%;
    height: auto;
}

/* RESET FINSIHED */
html {
    background-color: aliceblue;
}

h1:not(#document-result h1) {
    color: lavender;
    background-color: mediumblue;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 32px;
    font-weight: bold;
    padding: 2px;
}

#top-nav {
    color: white;
    background-color: mediumblue;
    padding-bottom: 2px;
}

#top-nav button {
    font-size: 1.4rem;
    padding: 5px;
    margin: 1px;
    min-height: 25px;
    background-color: #e0e0e0;
    border: #e0e0e0;
    border-radius: 5px;
}

h2:not(#document-result h2) {
    margin: 16px;
    /* padding: 2px; */
    /* background-color: mediumblue; */
    font-weight: bold;
    /* color: lavender; */
    text-align: center;
    padding: 2px;
    border-radius: 5px;
    font-family: Arial, Helvetica, sans-serif;
    border: 1px solid grey;
}

#main-planner h2 {
    color: black;
    background-color: orange;
}


#main-notes h2 {
    background-color: orange;
    color: black;
}

#main-write h2 {
    background-color: cadetblue;
}

#main-tables h2 {
    background-color: forestgreen;
    color: antiquewhite;
}

/* #main-write h2:not(#document-result h2) {
    background-color: cadetblue;
    color: antiquewhite;
} */

#main-write h2 {
    background-color: cadetblue;
    color: antiquewhite;
}

#main-calculator h2 {
    background-color: dimgrey;
    color:snow;
}

#document-result h1,
#document-result h2,
#document-result h3,
#document-result h4 {
    background-color: unset;
    color: unset;
}

#document-result * {
    background-color: unset;
    width: unset;
    text-align: unset;
    border-radius: unset;
    margin-left: unset;
    margin-right: unset;
    width: unset;
    padding-bottom: unset;
    align-items: unset;
    border-radius: unset;
    margin: unset;
    padding: unset;
}

#document-parent {
    margin: 0;
    padding: 0;
    width: 100%;
    background-color: lightgoldenrodyellow;
}

#document-result {
    overflow-wrap: break-word;
    min-height: 100px;
    width: auto;
    background-color: lightgoldenrodyellow;
    white-space: pre-wrap;
}

main {
    background-color: #e0e0e0;
    /* border: 1px solid orange; */
}

body {
    width: 320px;
    background-color: lightskyblue;
    background-color: #e0e0e0;
    margin: auto;
    padding: 5px;
    box-sizing: border-box;
}

h1:not(#document-result h1),
h2:not(#document-result h2),
h3:not(#document-result h3),
nav {
    display: flex;
    flex-direction: row;
    justify-content: center;
}


#edit-bar,
#document-settings {
    display: flex;
    justify-content: left;
    flex-wrap: wrap;
    background-color: cadetblue;
    border: 1px solid black;
    margin: 0;
    padding: 0;
}

#edit-bar button,
#document-settings button {
    border-radius: 5px;
    background-color: #e0e0e0;
    border: 1px solid grey;
    padding: 1px 4px;
    margin: 0;
}

#text-editor {
    width: 100%;
    max-width: 100%;
    overflow-wrap: break-word;
    min-height: 100px;
    margin-top: 0px;
    margin-bottom: 0px;
}

footer {
    position: fixed;
    bottom: 0;
    left: 50%;
    transform: translate(-50%, 0%);
}

button {
    padding: 5px;
}

#main-planner,
#main-notes,
#main-write,
#main-tables,
#main-calculator {
    display: flex;
    flex-direction: column;
}

/* #planner-ribbon{
    border-bottom: 1px solid lightslategray;
    padding-bottom: 0.5re;
}
#main-planner h3{
    border-bottom: 1px solid lightslategray;
} */
#planner-ribbon>button{
    font-size: 18px;
}
main {
    min-height: 320px;
}

#planner-contacts-form *,
#planner-calendar-form * {
    width: 100%;
    display: auto;
    box-sizing: border-box;
}

#planner-planner-help ul li, #tables-help ul li {
    list-style-position: inside;
    list-style-type: disc;
    margin: 0 15px;
}
#planner-planner-help ol li, #tables-help ol li {
    list-style-position: inside;
    list-style-type:decimal;
    margin: 0 15px;
}


#planner-planner-help p,#tables-help p {
    margin: 15px;
}
#planner-help, #tables-help pre{
    font-size: 12px;
}

#Description{
    height:100px;
}

.table-container table,
.table-container table td,
.table-container table th {
    border: 1px solid black;
    border-collapse: collapse;
}

.table-container pre {
    /* https://stackoverflow.com/questions/248011/how-do-i-wrap-text-in-a-pre-tag */
    white-space: pre-wrap;
    font-size: 12px;
    word-break: break-all;
}

.table-container table {
    box-sizing: border-box;
    margin: auto;
    width: 100%;
    /* min-height: 100px; */
}

#contacts-table th,
#contacts-table td,
#calendar-table th,
#calendar-table td {
    display: none;
}

#calendar-table th:nth-of-type(1),
#calendar-table th:nth-of-type(2),
#calendar-table th:nth-of-type(3),
#calendar-table td:nth-of-type(1),
#calendar-table td:nth-of-type(2),
#calendar-table td:nth-of-type(3) {
    display: table-cell;
}


#contacts-table td:nth-of-type(1),
#contacts-table th:nth-of-type(1),
#contacts-table th:nth-of-type(4),
#contacts-table td:nth-of-type(4) {
    display: table-cell;
    /* max-width:7rem; */
    /* overflow-wrap:break-word; */
}

#contacts-table th:nth-of-type(3),
#contacts-table td:nth-of-type(3) {
    display: table-cell;
    /* max-width:5rem;
     overflow-wrap:break-word; */
}

#calendar-container {
    margin: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
}

#special-calendar {
    background-color: snow;
        /* font-family: 'Courier New', Courier, monospace; */
        font-family: Arial, Verdana, Helvetica, Tahoma, sans-serif;
        font-size: 16px;
        padding: 0;
        margin: 0;
        background-color: white;
}
#special-calendar table td{
    height: 32px;
    text-align: center;
    width: 32px;
}
#special-calendar {
    border: 1px solid grey;
    width: 240px;
}
#month-chooser{
    background-color: #F5F5F5;
    min-height: 30px;
    border-radius: 5px;
    width: 240px;
    text-align: center;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 16px;
}


#calendar-date {
    display: none;
}

/* #UID{
    display: none;
} */
main h3 {
    background-color: #e0e0e0;
}

.nested-menu:hover {
    color: snow;
    background-color: grey;
}

/* TABLES APP */
#tables-table th:hover:not(:first-of-type),
#tables-table td:first-of-type:hover {
    background-color: white;
}

#add-row:hover,
#add-column:hover {
    background-color: white;
}
/* #add-row, */
/* not needed due to th first of type */
#add-column
{
   min-width: 1rem;
}

.table-container {
    display: block;
    overflow-x: auto;
    margin-left: auto;
    margin-right: auto;
    width: 100%;
    text-align: center;
}

#tables-table input {
    width: 100%;
    border: none;
}

#tables-table input:hover {
    background-color: lightgrey;
}

#tables-table td {
    padding: 0px;
}

/* NEXT 2 Keep From collapsing first last columns */
#tables-table th:not(:last-of-type) {
    min-width: 3rem;
}

#tables-table th:first-of-type {
    min-width: 1rem;
}

#tables-table {
    border: none;
}

/* #tables-table tfoot, 
#tables-table tfoot tr, */
/* #tables-table tfoot th {
    border: none;
} */

#tables-table th {
    border: none;
}

.tables-table-row-number {
    border: none !important;

}

#tables-table {
    background-color: lightgrey;
}

#tables-table-table {}

#tables-tables-header-form>div,
#tables-tables-row-form>div {
    display: flex;
    flex-direction: column;
    text-align: center;
    width: 50%;
    margin: auto;
}

#tables-tables-header-form *,
#tables-tables-row-form * {
    text-align: center;
}

/* Handles groups of inputs and buttons together on form */
#tables-tables-header-form>div>div, #tables-tables-row-form>div>div {
    margin: 5px 0px;
}

#tables-tables-header-form>div>div>*, #tables-tables-row-form>div>div>* {
    width: 100%;
}



/*  CALCULATOR STUFF */

#calculator-table {
    width: 100%;
    min-width: 0%;
}

#calculator-table td button {
    font-size: 2rem;
    width: 100%;
    height: 4rem;
}

.special-calculator-button {
    background-color: #ffcc33;
    border: 1px solid grey;
}

#last-calculator-expression {
    overflow-wrap: anywhere;
    min-height: 18px;
    color: grey;
}

#calculator-input {
    width: 100%;
    height: 40px;
    font-size: 1.4rem;
    text-align: right;
}

#calc-clr button {
    width: 50%;
    font-size: 1.4rem;
    padding: 5px;
}

main nav button{
    /* border-radius: 5px;
    border:1px solid grey; */
    background-color: #e0e0e0;
    border: 1px solid grey;
    border-radius: 3px;
    /* font-size: 12px; */
}

/* make dim grey color */
#startup-load-button, #startup-save-button{
    font-size: 1.4rem;
}
#planner-load,#planner-save{
    /* background-color: aliceblue; */
    margin: 40px;
    /* border-radius: 1rem; */
}
#planner-contacts-table, #planner-calendar-start{
    margin-top: 1rem;
}
#planner-contacts-table nav, #planner-calendar-start nav{
    /* background-color: #ffcc33; */
    min-height: 36px;
}
#new-contacts-button{
    font-size: 1.4rem;
    padding: 4px 10px;
}
#contacts-table{
    margin-top: 10px;
}

</style><link id="favicon-link" rel="icon" type="image/x-icon" href="">
<title>bitOffice</title>
</head>

<body>
    <h1 onclick="alert(license);">bitOffice</h1>
    <nav id="top-nav">
        <button onclick="showMain('main-planner');">&#9742;&#128197;</button>
        <button onclick="showMain('main-notes');">&#128196;</button>
        <button onclick="showMain('main-write');">&#128221;</button>
        <button onclick="showMain('main-tables');">&#9638;</button>
        <button onclick="showMain('main-calculator');">&#128290;</button>
        <button onclick="saveSelf()">&darr;</button>
    </nav><main id="main-planner">
    <h2 id="planner-h2">Planner</h2>
    <!-- <nav id="back-home-nav">
            <button onclick="backHomePlanner();">&larr;Back to Main</button>
        </nav> -->

        
    <nav id="planner-ribbon">
        <!-- <button onclick="showPlannerDiv('planner-startup');">&#128194;</button>
            <button onclick="showPlannerDiv('planner-contacts-table');">&#9742;</button>
            <button onclick="showPlannerDiv('planner-calendar-start');makeCalendar();">&#128197;</button>
            <button onclick="showPlannerDiv('planner-planner-help');">?</button> -->
        <!-- <button onclick="showPlannerDiv('planner-startup');">&#128194;</button> -->
        <button onclick="showPlannerDiv('planner-load');">&#128194;</button>
        <button onclick="showPlannerDiv('planner-save');">&#128193;</button>
        <button onclick="showPlannerDiv('planner-contacts-table');">&#9742;</button>
        <button onclick="showPlannerDiv('planner-calendar-start');makeCalendar();">&#128197;</button>
        <button onclick="showPlannerDiv('planner-planner-help');">?</button>
    </nav>
    <!-- <div class="planner-div" id="planner-home">
        <h3>Planner-Home</h3>
    </div> -->
    <!-- <div class="planner-div" id="planner-startup">
        <h3>Planner-Load/Save</h3>
        <nav>
            <button id="startup-load-button" onclick="loadCombinedDatabase()">&#128194; Load</button>
            <button id="saveButton" onclick="saveCombinedDatabase()">&#128193; Save</button>
        </nav>
    </div> -->
    <div class="planner-div" id="planner-load">
        <!-- <h3>Planner-Load</h3> -->
        <nav>
            <button id="startup-load-button" onclick="loadCombinedDatabase()">Load<br>&#128194;</button>
            <!-- <button id="saveButton" onclick="saveCombinedDatabase()">&#128193; Save</button> -->
        </nav>
    </div>
    <div class="planner-div" id="planner-save">
        <!-- <h3>Planner-Save</h3> -->
        <nav>
            <!-- <button id="startup-load-button" onclick="loadCombinedDatabase()">&#128194; Load</button> -->
            <button id="startup-save-button" onclick="saveCombinedDatabase()">Save<br>&#128193;</button>
        </nav>
    </div>
    <div class="planner-div" id="planner-planner-help">
        <h3>Planner-Help</h3>

        <p>You can:
        <ul>
            <li>Load/Save your data to its native format. This will save both the Contacts and Calendar in one file.
            </li>
            <li>You can export all contacts to a file containing vCards</li>
            <li>You can a single vCard</li>
            <li>You can export your entire calendar in vCalendar format (.ics format)</li>
            <li>You can export a single event in vCalendar format (.ics format)</li>
        </ul>
        </p>
        <p>
            Most programs like Google Calendar or Microsoft Outlook can import or export these files.
        </p>
        <hr>
        <p>
            <i>Notes on importing:</i>
        </p>

        <p>
            The program only supports a limited number of fields. When importing from a
            different program, any fields not supported will be read into the "Notes" area on Contacts and the
            "Description" area on Calendar entries. Also, photos, audio, and video are not supported.
        </p>
    </div>
    <div class="planner-div" id="planner-contacts-table">
        <!-- <h3>Planner-Contacts</h3> -->
        <nav>
            <!--<button onclick="processCSVClick(contactsTable);">CSV</button>-->


            <button id="new-contacts-button" onclick='newContactsEntry();'>+</button>
            <nav>
                <!-- <button onclick="loadOutlookContactsCSV();">&#128194; Import CSV</button>
                    <button onclick="saveOutlookContactsCSV();">&#128193; Export CSV</button> -->
                <button onclick="importVCF();">&#128193; Import vCards</button>
                <button onclick="exportVCF();">&#128193; Export vCards</button>
                <button onclick="removeDuplicateContacts();">&#128589;&#128589;Remove Duplicate Contacts</button>
                <button class="nested-menu">&lrarr;</button>
            </nav>
        </nav>

        <div id="contacts-table" class="table-container"></div>
    </div>
    <div class="planner-div" id="planner-contacts-form">
        <!-- <h3>Planner-Contacts Form</h3> -->
        <div id="contacts-edit-form-message"></div>
        <div id="contacts-edit-form"></div>
        <nav>
            <button onclick='saveContactsEntry();'>Save</button>
            <button onclick='deleteContactsEntry();'>Delete</button>
            <button onclick='cancelContactsEntry();'>Cancel</button>
            <button onclick='exportSingleVCard()'>Export vCard</button>
        </nav>
    </div>
    <div class="planner-div" id="planner-calendar-start">
        <!-- <h3>Planner-Calendar</h3> -->
        <nav>
            <!-- <button onclick="loadOutlookCSV();">&#128194; Import CSV</button>
                <button onclick="createOutlookCSV();">&#128193; Export CSV</button> -->
            <button onclick="importICSCalendar()">&#128194; Import vCalendar</button>
            <button onclick="exportICSCalendar()">&#128193; Export vCalendar</button>
            <button onclick="clearCalendar();">Clear Calendar</button>
            <button class="nested-menu">&lrarr;</button>
        </nav>

        <div id="calendar-container">
            <div><input type='date' id="calendar-date"></div>
            <input id="month-chooser" type="month">
            <div id="special-calendar"></div>
        </div>
    </div>
    <div class="planner-div" id="planner-calendar-table">
        <h3 id="calendar-table-name"></h3>
        <nav>
            <button onclick='newCalendarEntry();'>+ New Entry</button>
            <button onclick="processCalendarHome();">Back to Main Calendar</button>
            <!-- <button onclick="processCalendarCSVClick();">CSV</button> -->
        </nav>
        <div id="calendar-table" class="table-container"></div>
    </div>
    <div class="planner-div" id="planner-calendar-form">
        <h3 id="calendar-edit-form-message"></h3>
        <div id="calendar-edit-form"></div>
        <nav>
            <button onclick='saveCalendarEntry();'>Save</button>
            <button onclick='deleteCalendarEntry();'>Delete</button>
            <button onclick='cancelCalendarEntry();'>Cancel</button>
            <button onclick="exportSingleICalEvent()">Export Event</button>
        </nav>
    </div>
</main><main id="main-notes">
    <h2>Notes</h2>
    <nav>
        <button onclick="newNotesEntry()">New</button>
        <button onclick="notesLoad()">Load</button>
        <button onclick="notesSave()">Save</button>
        <button id="copy" onclick="copyToClipBoard(document.getElementById('note').value);">Copy</button>
        <button onclick="printNotesDiv('note');">&#128424;</button>
        <button class="plus-minus" onclick="changeFontSize(this);">-</button>
        <button class="plus-minus" onclick="changeFontSize(this);">+</button>
        <button onclick="simulateUndo()">&#10226;</button>
        <button onclick="simulateRedo()">&#10227;</button>
    </nav>
    <textarea id="note" rows="10" placeholder="your notes here"></textarea>
</main><main id="main-write">
    <h2>Write</h2>
    <nav id="file-bar">
        <button onclick="newDocument();">New</button>
        <button onclick="writeLoad();">Load</button>
        <button onclick="writeDataToJSON();">Save</button>
        <button onclick="exportToHTML()">Export</button>
        <button onclick="printDiv('document-parent');//window.print()">&#128424;</button>
    </nav>
    <nav id="document-settings">
        <button class="mono" onclick='processSelectedText(this);'>Mono</button>
        <button class="serif" onclick='processSelectedText(this);'>Serif</button>
        <button class="sans" onclick='processSelectedText(this);'>Sans</button>
        <button onclick='processSelectedText(this);//decrease font'><sup>A</sup>A</button>
        <button onclick='processSelectedText(this);//increase font;'><sub>A</sub>A</button>
        <button onclick='processSelectedText(this);//inc margin;'>&rarrb;&larrb;</button>
        <button onclick='processSelectedText(this);//dec margin;'>&larrb;&rarrb;</button>
        <button onclick='processSelectedText(this);//align left;'>&#8666;</button>
        <button onclick='processSelectedText(this);//align center;'>&#8667;&#8666;</button>
        <button onclick='processSelectedText(this);//align right;'>&#8667;</button>
        <button id="spell-check" onclick='processSelectedText(this);//spellcheck;'>&check;</button>
    </nav>
    <nav id="edit-bar">
        <button onclick='processSelectedText(this);'><b>B</b></button>
        <button onclick='processSelectedText(this);'><u>U</u></button>
        <button onclick='processSelectedText(this);'><em>I</em></button> &nbsp;
        <button onclick='processSelectedText(this);'>&#8633;</button>
        <button onclick='processSelectedText(this);//paragraph;'>&para;</button>
        <button onclick='processSelectedText(this);'>H1</button>
        <button onclick='processSelectedText(this);'>H2</button>
        <button onclick='processSelectedText(this);'>H3</button> &nbsp;
        <button onclick='processSelectedText(this);//horizontal rule'>&#8213;</button>
        <button onclick='processSelectedText(this);//bullet;'>&bullet;</button> &nbsp;
        <button onclick='processSelectedText(this);//undo;'>&#10226;</button>
        <button onclick="writeRedo()">&#10227;</button>
    </nav>
    <textarea id="text-editor" spellcheck="false" oninput="writeUpdateResult();"></textarea>
    <div id="document-parent">
        <div id="document-result"></div>
    </div>
</main><main id="main-tables">
    <h2>Tables</h2>
    <nav>
        <button onclick="tablesNewTable();">New</button>
        <button onclick="tablesLoad();">Load</button>
        <button onclick="tablesSave();">Save</button>
        <button onclick="tablesCopyCSVToClipboard()">Copy</button>
        <button onclick="showTablesDiv('tables-help');">?</button>
    </nav>
    <div class="tables-div" id="tables-tables-table">

        <div class="table-container">
            <table id="tables-table">
            </table>
        </div>
    </div>
    <div class="tables-div" id="tables-tables-header-form">
        <!-- <h2>Tables</h2> -->
        <div>
            <h3>Column: <span id="tables-current-header">header name here</span></h3>

            <div class="surround-box">
                <button onclick="updateHeaderName();">Change name to:</button>
                <input id="tables-new-header-name" type="text" placeholder="name">
            </div>
            <div class="surround-box">
                <button onclick="deleteColumn();">Delete Column</button>
                <button onclick="copyColumn()">Copy Column</button>
            </div>
            <div class="surround-box">
                <button onclick="moveColumn()">Move To Column</button><select id="move-column"></select>
            </div>
            <div>
                <button onclick="calculateTotal()">Add Total</button>
                <button onclick="calculateAverage()">Compute Average</button>
            </div>
            <div>
                <button onclick="tablesSort(1)">Sort Ascending &uarr;</button>
                <button onclick="tablesSort(-1)">Sort Descending &darr;</button>
            </div>
            <div>
                <button onclick="tablesCancel()">Cancel</button>
            </div>
        </div>
    </div>
    <div class="tables-div" id="tables-tables-row-form">
        <!-- <h2>Tables</h2> -->
        <div>
            <h3>Row: <span id="tables-current-row">row number here</span></h3>
            <div>
                <button onclick="deleteRow()">Delete Row</button>
                <button onclick="copyRow()">Copy Row</button>
            </div>
            <div>
                <button onclick="moveRow()">Move To Row</button>
                <select id="move-row"></select>
            </div>
            <div>
                <button onclick="tablesCancel()">Cancel</button>
            </div>
        </div>
    </div>
    <div class="tables-div" id="tables-help">
        <p>
        <h3>Tables-Help</h3>
        </p>
        <p>
        <nav><button onclick="showTablesDiv('tables-tables-table');">Back To Table</button></nav>
        </p>
        <p>FORMATTING RULES:</p>
        <p>When Saving:
        <ol>
            <li>All cells are quoted text.
            </li>
            <li>Interior double quotes in cells are converted like this: "-&gt;""</li>
        </ol>
        </p>
        <p>If loading CSV from other apps:
        <ol>
            <li>Cells should all be text type.</li>
            <li>Quote all text strings when saving is best practice.</li>
            <li>There should be no spaces or tabs between the comma delimiter.</li>
            <li>Interior double quotation marks (i.e. ") in a cell should be stored as ""</li>
        </ol>
        </p>
        <p>
            For example, these 2 cell contents:
        <pre>  She said "Yeah, Yeah, Yeah",Hi</pre>
        </p>
        <p>
            Would be stored as
        <pre>  "She said ""Yeah, Yeah, Yeah""","Hi"</pre>
        </p>
        <hr>
        <p>
            <i>Notes on CSV:</i>
        </p>
        <p>
            There is no universal standard among programs, but this program uses the following standards
            adapted from <a href="https://en.wikipedia.org/wiki/Comma-separated_values#Standardization" target="_blank">RFC 4180 and MIME standards</a>.:
        <ul>
            <li>Each record should contain the same number of comma-separated fields.</li>
            <li>Any field may be quoted (with double quotes).</li>
            <li>If double-quotes are used to enclose fields, then a double-quote in a field must be represented by two double-quote characters. (internal " is escaped with "")</li>
            <li>Some type of carriage return/line feed must be used- this program uses the "\n" convention, not "\r\n".</li>
        </ul>
        </p>
    </div>
</main><main id="main-calculator">
    <h2>Calculator</h2>
    <input type=text id='calculator-input'>
    <nav id="calc-clr">
        <button class="special-calculator-button" id="clear-calc">CLR</button>
        <button id="remove-last-char">&larr;</button>
    </nav>

    <div id="last-calculator-expression"></div>
    <table id="calculator-table">
        <tr>
            <td><button class='build-calc-string'>7</button></td>
            <td><button class='build-calc-string'>8</button></td>
            <td><button class='build-calc-string'>9</button></td>
            <td><button class='build-calc-string'>/</button></td>
        </tr>
        <tr>
            <td><button class='build-calc-string'>4</button></td>
            <td><button class='build-calc-string'>5</button></td>
            <td><button class='build-calc-string'>6</button></td>
            <td><button class='build-calc-string'>*</button></td>
        </tr>
        <tr>
            <td><button class='build-calc-string'>1</button></td>
            <td><button class='build-calc-string'>2</button></td>
            <td><button class='build-calc-string'>3</button></td>
            <td><button class='build-calc-string'>-</button></td>
        </tr>
        <tr>
            <td><button class='build-calc-string'>0</button></td>
            <td><button class='build-calc-string'>.</button></td>
            <td><button class="special-calculator-button" id="equals-button">=</button></td>
            <td><button class='build-calc-string'>+</button></td>
        </tr>
    </table>
</main><footer onclick="alert(license)">bitOffice &copy; 2022</footer><script>let license = "MIT License\n\n\
Copyright (c) 2022 Gary Davenport\n\n\
Permission is hereby granted, free of charge, to any person obtaining a copy \
of this software and associated documentation files (the \"Software\"), to deal \
in the Software without restriction, including without limitation the rights \
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \
copies of the Software, and to permit persons to whom the Software is \
furnished to do so, subject to the following conditions:\n\n\
The above copyright notice and this permission notice shall be included in all \
copies or substantial portions of the Software.\n\n\
THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \
SOFTWARE.";









////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                                                                //
// FUNCTION NAME                                       				INPUT                                           OUTPUT                                        //
// csvToArrays(csvString)                              				csv                                             array of arrays                               //
// arraysToCSV(arrayOfArrays,newLineString="\n")       				array of arrays, "\n" or "\r\n"                 csv                                           //
// arraysToJSON(arrays, usingHeaders)                  				array of arrays                                 JSON {["headers"]=[],["data"]=[{},{},{}...]}  //
// JSONToArrays(jsonObject, includeHeaders)            				JSON {["headers"]=[],["data"]=[{},{},{}...]}    array of arrays                               //
// unorderdJSONToArrays(jsonObject,includeHeaders)     				JSON [{"key":"value"},{k:v},...]                array of arrays                               //
//                                                                                                                                                                //
// COMPOSITE FUNCTIONS:                                                                                                                                           //
// csvToJSON(csvString, usingHeaders)                  				csv                                             JSON {["headers"]=[],["data"]=[{},{},{}...]}  //                                        
// JSONToCSV(jsonObject, includeHeaders=true,newLineString="\n")	JSON {["headers"]=[],["data"]=[{},{},{}...]}    csv                                           //
// unorderedJSONToCSV(jsonObject, includeHeaders)      				JSON [{"key":"value"},{k:v},...]                csv                                           //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


function _replaceReallCommmasInCSV(contents, commaReplacement) {

    //temp fix
    //contents=contents.split("\r\n").join("\n");
    //temp fix
    let newContents = "";
    let inside = -1;
    for (let i = 0; i < contents.length; i++) {
        let thisChar = contents.charAt(i);
        if (thisChar === '"') {
            inside = inside * -1;
            newContents += thisChar;
        }
        else if (thisChar === ",") {
            if (inside === -1) {//comma is outside of quotes, replace
                newContents += commaReplacement;
            }
            else {//comma is inside of quotes, don't replace
                newContents += thisChar;
            }
        }
        // else if (thisChar === "\n") {
        //     if (inside === -1) {//\n is outside of quotes, replace
        //         newContents += newlineReplacement;
        //     }
        //     else {//comma is inside of quotes, don't replace
        //         newContents += thisChar;
        //     }
        // }
        else {
            newContents += thisChar;
        }
    }
    return (newContents);
}

function _replaceRealNewlinesInCSV(contents, newLineReplacement) {
    //temp fix
    //contents=contents.split("\r\n").join("\n");
    //temp fix
    let newContents = "";
    let inside = -1;
    for (let i = 0; i < contents.length; i++) {
        let thisChar = contents.charAt(i);
        if (thisChar === '"') {
            inside = inside * -1;
            newContents += thisChar;
        }
        // else if (thisChar === ",") {
        //     if (inside === -1) {//comma is outside of quotes, replace
        //         newContents += commaReplacement;
        //     }
        //     else {//comma is inside of quotes, don't replace
        //         newContents += thisChar;
        //     }
        // }
        else if (thisChar === "\n") {
            if (inside === -1) {//\n is outside of quotes, replace
                newContents += newLineReplacement;
            }
            else {//comma is inside of quotes, don't replace
                newContents += thisChar;
            }
        }
        else {
            newContents += thisChar;
        }
    }
    return (newContents);
}



function _replaceRealCommasAndRealNewlinesInCSV(contents, commaReplacement, newlineReplacement) {
    //temp fix
    //contents=contents.split("\r\n").join("\n");
    //temp fix
    let newContents = "";
    let inside = -1;
    for (let i = 0; i < contents.length; i++) {
        let thisChar = contents.charAt(i);
        if (thisChar === '"') {
            inside = inside * -1;
            newContents += thisChar;
        }
        else if (thisChar === ",") {
            if (inside === -1) {//comma is outside of quotes, replace
                newContents += commaReplacement;
            }
            else {//comma is inside of quotes, don't replace
                newContents += thisChar;
            }
        }
        else if (thisChar === "\n") {
            if (inside === -1) {//\n is outside of quotes, replace
                newContents += newlineReplacement;
            }
            else {//comma is inside of quotes, don't replace
                newContents += thisChar;
            }
        }
        else {
            newContents += thisChar;
        }
    }
    //new added this will replace the "\r\n" with "\n", some programs
    //use the \r\n (ms outlook for example) instead of \n
    //newContents=JSON.stringify(newContents);
    //newContents.split("\"\r"+newlineReplacement).join(newlineReplacement);
    //newContents=JSON.parse(newContents);
    return (newContents);
}


function tokenMaker(intSize) {
    let token = "";
    let specialString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    for (let i = 0; i < intSize; i++) {
        token += specialString[Math.floor(Math.random() * specialString.length)];
    }
    //console.log(token);
    return token;
}

//Works with earlier versions of NodeJS and anywhere replaceAll not available
//from: https://stackoverflow.com/questions/62825358/javascript-replaceall-is-not-a-function-type-error
//author: https://stackoverflow.com/users/9513184/unmitigated
//Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}
function myReplaceAll(str, match, replacement) {
    return str.replace(new RegExp(escapeRegExp(match), 'g'), () => replacement);
}


function getTokenNotInString(myString, intSize = 16) {
    let token = tokenMaker(16);
    while (myString.indexOf(token) !== -1) {
        token = tokenMaker(16);
    }
    return token;
}
function csvToArrays(CSVString) {
    // CSVString.split("\r\n").join("\n");
    // CSVString.split("\r\n").join("\n");
    //CSVString = myReplaceAll(CSVString,"\r\n", "\n");

    CSVString=CSVString.trim();

    let carriageReturnToken = getTokenNotInString(CSVString);
    CSVString = CSVString.split("\r").join(carriageReturnToken);
    CSVString = CSVString.split(carriageReturnToken + "\n").join("\n");

    let myArray = []; //initialization
    CSVString = CSVString.trim();

    let commaToken = getTokenNotInString(CSVString);

    CSVString = _replaceReallCommmasInCSV(CSVString, commaToken);

    let newlineToken = getTokenNotInString(CSVString);
    //find a string that is not present in CSV for using as temporary tag
    //while (CSVString.indexOf(newlineToken) !== -1) {
    //    newlineToken = tokenMaker(16);
    //}

    CSVString = _replaceRealNewlinesInCSV(CSVString, newlineToken);
    /////////////REALLY should be doing one string replacement at a time, not 2

    //CSVString = _replaceRealCommasAndRealNewlinesInCSV(CSVString, commaToken, newlineToken);

    let lines = CSVString.split(newlineToken);

    for (let i = 0; i < lines.length; i++) {
        //an array of cells from row in csv line
        //it contains the quotes and is formatted with double quotes
        let rowArray = lines[i].split(commaToken);
        for (let j = 0; j < rowArray.length; j++) {

            //remove outer quotes if present
            if (rowArray[j][rowArray[j].length - 1] === '"') {
                
                rowArray[j] = rowArray[j].slice(0, rowArray[j].length - 1);
            }
            if (rowArray[j][0] === '"') {
                rowArray[j] = rowArray[j].slice(1, rowArray[j].length);
            }
            //replace double inner quotes with singles
            rowArray[j] = rowArray[j].split('""').join('"');
        }
        myArray.push(rowArray);
    }
    return myArray;
}

function arraysToCSV(arrayOfArrays, newLineString = "\n") {
    let CSVString = "";
    //go through each 'line'
    for (let i = 0; i < arrayOfArrays.length; i++) {
        //go through each csv cell and build line
        for (let j = 0; j < arrayOfArrays[i].length; j++) {
            CSVString += '"';
            CSVString += arrayOfArrays[i][j].split('"').join('""');
            CSVString += '",'
        }
        CSVString = CSVString.slice(0, -1) + newLineString; //takes off last comma and adds new line
    }
    CSVString = CSVString.slice(0, -(newLineString.length)); //takes off last \n character
    return CSVString;
}

function arraysToJSON(arrayOfArrays, usingHeaders = true) {
    let headers = [];
    let data = [];
    let table = {};
    if (usingHeaders === true) {                                //read in headers
        for (let i = 0; i < arrayOfArrays[0].length; i++) {
            let header = arrayOfArrays[0][i];
            let index = 0;
            while (headers.includes(header)) {                  //prevents duplicates
                console.log("WARNING - Duplicate header found: " + header);
                index += 1;
                header = header + index.toString();
                console.log("Attempting rename to: " + header);
            }
            headers.push(header);
        }
    } else {
        for (let i = 0; i < arrayOfArrays[0].length; i++) {     //make headers
            headers.push("header" + i.toString());
        }
    }
    if (usingHeaders === true) {
        startRow = 1;
    }
    else {
        startRow = 0;
    }
    for (let i = startRow; i < arrayOfArrays.length; i++) {//go throught every line
        let tempRow = {};
        for (let j = 0; j < headers.length; j++) {
            tempRow[headers[j]] = arrayOfArrays[i][j];
        }
        // console.log(tempRow);
        data.push(tempRow);
    }
    table["headers"] = headers;
    table["data"] = data;
    // console.log(JSON.stringify(table))
    return (table);
}

function JSONToArrays(jsonObject, includeHeaders = true) {
    let headers = jsonObject["headers"];
    let data = jsonObject["data"];
    let arrayOfArrays = [];
    if (includeHeaders === true) {
        let row = [];
        for (let i = 0; i < headers.length; i++) {
            row.push(headers[i].toString());
        }
        arrayOfArrays.push(row);
    }
    for (i = 0; i < data.length; i++) {
        let row = [];
        for (let j = 0; j < headers.length; j++) {
            if (data[i][headers[j]] === undefined) {
                row.push("");
            }
            else {
                row.push(data[i][headers[j]].toString());
            }
        }
        arrayOfArrays.push(row);
    }
    return (arrayOfArrays);
}

function unorderedJSONToArrays(jsonObject, includeHeaders = true) {
    //takes an array of objects [{},{},{}] where objects have key/value pairs
    let newObject = {};
    newObject["data"] = jsonObject;
    let headers = [];
    for (rowObject of jsonObject) { //rows of objects
        for (const key in rowObject) {
            if (!headers.includes(key)) {
                headers.push(key.toString());
            };
        }
    }
    newObject["headers"] = headers;
    return JSONToArrays(newObject, includeHeaders);
}

//COMPOSITE FUNCTIONS
function csvToJSON(csvString, usingHeaders = true) {
    let arrays = csvToArrays(csvString);
    console.log(arrays);
    let jsonObject = arraysToJSON(arrays, usingHeaders);
    return jsonObject;
}

function JSONToCSV(jsonObject, includeHeaders = true, newLineString = "\n") {
    let arrays = JSONToArrays(jsonObject, includeHeaders);
    let csvString = arraysToCSV(arrays, newLineString);
    return csvString;
}

function unorderedJSONToCSV(jsonObject, includeHeaders = true) {
    let arrays = unorderedJSONToArrays(jsonObject, includeHeaders);
    let csvString = arraysToCSV(arrays);
    return csvString;
}

function saveStringToTextFile(str1, basename = "myfile", fileType = ".txt",mimeType="text/plain") {
    let filename = basename + fileType;
    let blobVersionOfText = new Blob([str1], {
        type: mimeType,
    });
    let urlToBlob = window.URL.createObjectURL(blobVersionOfText);
    let downloadLink = document.createElement("a");
    downloadLink.style.display = "none";
    downloadLink.download = filename;
    downloadLink.href = urlToBlob;
    document.body.appendChild(downloadLink);
    downloadLink.click();
    downloadLink.parentElement.removeChild(downloadLink);
}

function copyAndSaveString(str1, basename = "myfile", fileType = ".txt", mimeType="text/plain") {
    copyToClipBoard(str1, false);
    if (confirm("Copied to clipboard, save to file also?")) {
        saveStringToTextFile(str1, basename, fileType, mimeType);
    }
}

function saveWebsiteAsTextFile(url) {
    //note requires header in php file
    let http = new XMLHttpRequest();
    http.timeout = 2000; // time in milliseconds
    http.ontimeout = function (e) {
        alert("The request timed out.");
    };
    http.open('GET', url, true);
    http.onreadystatechange = function () {
        if (http.readyState == 4 && http.status == 200) {
            alert(http.responseText);
            console.log(http.responseText);
        }
    }
    http.send();
}

function saveSelf(){
    let docTitle=document.getElementsByTagName("title")[0].innerText;
    if (confirm("Duplicate and download " + docTitle + " ?")){
        saveStringToTextFile(selfString, docTitle + "Clone",".html");
    }

}

//Date related functions for convience, uses same format as input type="date"
function getTodaysDate() {
    let now = new Date();
    let day = ("0" + now.getDate()).slice(-2);
    let month = ("0" + (now.getMonth() + 1)).slice(-2);
    let today = now.getFullYear() + "-" + month + "-" + day;
    return today;
}

function getFirstDayOfThisMonthDate() {
    let now = new Date();
    let day = "01";
    let month = ("0" + (now.getMonth() + 1)).slice(-2);
    return now.getFullYear() + "-" + month + "-" + day;
}

function getLastDayOfThisMonthDate() {
    let now = new Date();
    let day = daysInThisMonth().toString();
    day = "0" + day;
    day = day.slice(-2);
    let month = ("0" + (now.getMonth() + 1)).slice(-2);
    return now.getFullYear() + "-" + month + "-" + day;
}

function daysInSomeMonth(someMonth, someYear) { //use jan month is 0
    return new Date(someYear, someMonth + 1, 0).getDate();
}

function daysInThisMonth() {
    thisDate = new Date();
    thisMonth = thisDate.getMonth();
    thisYear = thisDate.getYear();
    return daysInSomeMonth(thisMonth, thisYear);
}

function getDayOfWeek(isoYearMonthDay) {
    let d = new Date(isoYearMonthDay + "T00:00");
    return d.getDay(); //zero based day
}

///////////////// serialize to web page //////////////////////

function serializeElementToPage(id, extraStyle = "") {
    let boilerPlate1 = "<!DOCTYPE html><html lang='en'><head><meta charset='UTF-8'><meta http-equiv='X-UA-Compatible' content='IE=edge'><meta name='viewport' content='width=device-width, initial-scale=1.0'><title></title><style>";

    let allStyleTags = document.getElementsByTagName('style');

    let styleElementContent = "";
    for (let i = 0; i < allStyleTags.length; i++) {
        styleElementContent = allStyleTags[i].innerHTML;
    }
    let boilerPlate2 = "</style></head><body>";
    let boilerPlate3 = "</body></html>";
    let s = new XMLSerializer();
    let myElement = document.getElementById(id);
    let str = s.serializeToString(myElement);
    let htmlPage = boilerPlate1 + styleElementContent + extraStyle + boilerPlate2 + str + boilerPlate3;
    console.log(htmlPage);
    return htmlPage;
}

function simulateUndo() {
    document.execCommand('undo', false, null);
}

function simulateRedo() {
    document.execCommand('redo', false, null);
}

function askConfirm() {
    return "Did you remember to save your data?";
}

//page navigation//

function showMain(id) {
    //console.log("show mains called with " + id);
    let mains = document.getElementsByTagName('main');
    for (let main of mains) {
        main.style.display = "none";
    }
    document.getElementById(id).style.display = "flex";
}

//          clipboard function          //
function copyToClipBoard(str, message = true) {
    //https://techoverflow.net/2018/03/30/copying-strings-to-the-clipboard-using-pure-javascript/
    let el = document.createElement('textarea');
    el.value = str;
    el.setAttribute('readonly', '');
    el.style = {
        position: 'absolute',
        left: '-9999px'
    };
    document.body.appendChild(el);
    el.select();
    document.execCommand('copy');
    document.body.removeChild(el);
    if (message) {
        alert('Copied to Clipboard.');
    }
    return (str);
}


//  "Table" related functions where tables have data (array of objects) and header (array)
function fillInEmptyPropertyValues(table) {
    let data = table["data"];
    let headers = table["headers"];
    for (let i = 0; i < data.length; i++) { //fill in empty property values;
        for (let j = 0; j < headers.length; j++) {
            if (data[i][headers[j]] === undefined) {
                data[i][headers[j]] = "";
            }
        }
    }
}

//              CSV related functions                   //
function makeCSV(thisTable, saveWithHeader = true) { ////This one fixed
    return JSONToCSV(thisTable, saveWithHeader, "\n");
    // let csvString = "";
    // let tempString = "";
    // let headers = thisTable["headers"];
    // if (saveWithHeader === true) {
    //     //fill in header from object
    //     for (let header of headers) {
    //         tempString = header.toString().split('"').join('""'); //any interior " needs to be replaced with ""
    //         csvString += "\"" + tempString + "\","; //surround each field with quotes
    //     }
    //     csvString = csvString.slice(0, -1) + "\n"; //remove last comma and add new line
    // }
    // //fill in body data
    // let bodyData = thisTable["data"];
    // let numberOfRows = bodyData.length;
    // let numberOfColumns = headers.length;
    // for (let i = 0; i < numberOfRows; i++) {
    //     for (let j = 0; j < numberOfColumns; j++) {
    //         tempString = bodyData[i][headers[j]].toString().split('"').join('""'); //any interior " needs to be replaced with ""
    //         csvString += "\"" + tempString + "\","; //surround each field with quotes
    //     }
    //     csvString = csvString.slice(0, -1) + "\n"; //remove last comma and add new line
    // }
    // console.log(csvString);
    // return (csvString);
}



function tokenMaker(intSize) {
    let token = "";
    let specialString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    let index = 0;
    for (let i = 0; i < intSize; i++) {
        token += specialString[Math.floor(Math.random() * specialString.length)];
    }
    console.log(token);
    return token;
}

function processCSVClick(table) {
    let thisCSV = "";
    //if (confirm("Include header as first line in csv file?")) {
    thisCSV = makeCSV(table, true);
    //} else {
    //    thisCSV = makeCSV(table, false);
    //}
    copyToClipBoard(thisCSV);
    if (confirm("Table copied to CSV.\n\nSave to file also?")) {
        copyAndSaveString(thisCSV, table["name"] + getTodaysDate(), ".csv");
    }
}

//              sort array by field
function destructiveSort(arrayOfObjects, field, direction = 1) {
    //direction -1 is descending, otherwise ascending
    if (direction != -1) { direction = 1; }
    arrayOfObjects.sort((a, b) => {
        if (a[field] < b[field]) {
            return -1 * direction;
        }
        if (a[field] > b[field]) {
            return 1 * direction;
        }
        return 0;
    });
}

function destructiveDoubleSortAscending(arrayOfObjects, date, time) {
    arrayOfObjects.sort((a, b) => {
        if (a[date] > b[date]) {
            return 1;
        }
        else if (a[date] < b[date]) {
            return -1;
        }
        if (a[time] > b[time]) {
            return 1;
        }
        else if (a[time] < b[time]) {
            return -1;
        }
        return 0;
    });
}
// function sortF(ob1,ob2) {
//     if (ob1.strength > ob2.strength) {
//         return 1;
//     } else if (ob1.strength < ob2.strength) { 
//         return -1;
//     }

//     // Else go to the 2nd item
//     if (ob1.name < ob2.name) { 
//         return -1;
//     } else if (ob1.name > ob2.name) {
//         return 1
//     } else { // nothing to split them
//         return 0;
//     }
// }

function makeFavicon(letter, color, backgroundColor) {
    //put this in head of html document
    //<link id="favicon-link" rel="icon" type="image/x-icon" href="">
    let canvas = document.createElement('canvas');
    canvas.width = 16;
    canvas.height = 16;

    let ctx = canvas.getContext('2d');
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, 16, 16);

    let ctx2 = canvas.getContext("2d");
    ctx2.fillStyle = color;
    ctx2.font = "bold 12px Arial";
    ctx2.fillText(letter, 4, 12);

    let link = document.getElementById("favicon-link");
    link.href = canvas.toDataURL("image/x-icon");
}


//------------------contacts and calendar database ----------------------
let contactsTableElement = document.getElementById("contacts-table");
let contactsEditForm = document.getElementById("contacts-edit-form");
let contactsEditFormMessage = document.getElementById("contacts-edit-form-message");
let contactsSortAscending = 1;

let contactsTable = {
    "name": "Contacts",
    "headers": ["First Name", "Middle Name", "Last Name", "Mobile Phone", "Home Phone", "Business Phone", "E-mail Address", "Home Address", "Notes"],
    "inputTypes": {
        "First Name": "text",
        "Middle Name": "text",
        "Last Name": "text",
        "Mobile Phone": "tel",
        "Home Phone": "tel",
        "Business Phone": "tel",
        "E-mail Address": "email",
        "Home Address": "textarea",
        "Notes": "textarea"
    },
    "data": []
}

//----------------calendar-------------------------
let calendarTable = document.getElementById("calendar-table");
let calendarEditForm = document.getElementById("calendar-edit-form");
let calendarEditFormMessage = document.getElementById("calendar-edit-form-message");
let monthChooser = document.getElementById("month-chooser");
let daysAbbreviations = ["Sun", "Mon", "Tue", "Wed", "Thur", "Fri", "Sat"];
let calendarSortAscending = 1;

let calendarDatabase = {
    "name": "Calendar",
    "headers": ["Subject", "Start Date", "Start Time", "End Date", "End Time", "Description", "UID"],
    "inputTypes": {
        "Subject": "text",
        "Start Date": "date",
        "Start Time": "time",
        "End Date": "date",
        "End Time": "time",
        "Description": "textarea",
        "UID": "text"
    },
    "data": []
}

//	COMBINED DATABASE

let combinedDatabase = {
    "contacts": contactsTable,
    "calendar": calendarDatabase
}

///////////////////CALENDAR//////////////////////
initializeCalendarApp();

function initializeCalendarApp() {
    monthChooser.addEventListener("input", makeCalendar);
    monthChooser.addEventListener("change", makeCalendar);
    monthChooser.value = getTodaysDate().slice(0, -3);
    console.log(getTodaysDate().slice(0, -3));
    makeCalendar();
}

function processCalendarHome() {
    makeCalendar();
    showPlannerDiv("planner-calendar-start");
}

function processCalendarCSVClick() {
    let date = document.getElementById("calendar-date").value;;
    let tempTable = {};
    tempTable["data"] = [];

    for (let i = 0; i < calendarDatabase["data"].length; i++) {
        if (
            (date === calendarDatabase["data"][i]["Start Date"]) ||
            (date === calendarDatabase["data"][i]["End Date"]) ||
            ((date >= calendarDatabase["data"][i]["Start Date"]) && (date <= calendarDatabase["data"][i]["End Date"]))
        ) {

            tempTable["data"].push(calendarDatabase["data"][i]);
        }
    }

    tempTable["headers"] = calendarDatabase["headers"];
    //tempTable["data"] = calendarDatabase["data"];

    tempTable = JSON.parse(JSON.stringify(tempTable));

    tempTable["name"] = "Calendar";

    //destructiveSort(tempTable["data"], "Start Time");
    processCSVClick(tempTable);
}

function buildCalendarTableElement(date) { //needs headers data


    //first go through all entries in the calendars dates
    //if they meet the criteria, push them to an array, and add on their location/index in the base array
    //order the array by start time
    //use the array to build the table element
    //(make sure the element contains the index)

    let allRows = calendarDatabase["data"];
    let filteredRows = [];
    let numberOfColumns = calendarDatabase["headers"].length;
    //let numberOfRows = daysEntries.length;

    for (let i = 0; i < allRows.length; i++) {
        if (
            (date === allRows[i]["Start Date"]) ||
            (date === allRows[i]["End Date"]) ||
            ((date >= allRows[i]["Start Date"]) && (date <= allRows[i]["End Date"]))
        ) {
            let tempRow = JSON.parse(JSON.stringify(allRows[i]));
            tempRow["intBaseIndex"] = i;
            filteredRows.push(tempRow);
            //for (let i = 0; i < numberOfRows; i++) {
        }

    }

    //destructiveSort(filteredRows, "Start Time");

    destructiveDoubleSortAscending(filteredRows, "Start Date", "Start Time");

    //start table

    let tableElement = "";
    tableElement += "<table>";

    //build table header
    tableElement += "<thead><tr>";
    for (let j = 0; j < numberOfColumns; j++) {
        tableElement += "<th onclick='//sortCalendarByField(this);'>" + calendarDatabase["headers"][j] + "</th>";
    }
    tableElement += "</tr></thead>";
    //build table body	
    tableElement += "<tbody>";

    for (let i = 0; i < filteredRows.length; i++) {
        // if (
        //     (date === filteredRows[i]["Start Date"]) ||
        //     (date === filteredRows[i]["End Date"]) ||
        //     ((date >= filteredRows[i]["Start Date"]) && (date <= filteredRows[i]["End Date"]))
        // ) 
        {

            //for (let i = 0; i < numberOfRows; i++) {
            tableElement += "<tr id='calendar-table-row-" + i.toString() + "' onclick=\"selectCalendarEditForm(" + (filteredRows[i]["intBaseIndex"]).toString() + ")\">";
            for (let j = 0; j < numberOfColumns; j++) {
                let fieldName = calendarDatabase["headers"][j];
                tableElement += "<td><pre>" + filteredRows[i][fieldName] + "</pre></td>";
            }
            tableElement += "</tr>";
            //}

        }

    }

    tableElement += "</tbody>";

    return tableElement;


    //destructiveSort(calendarDatabase["dates"][date]["data"], calendarDatabase["headers"][0]); //sort by start time

    //let daysEntries = calendarDatabase["dates"][date]["data"];

}



function newCalendarEntry(table) {
    //show what's being edited
    calendarEditFormMessage.innerHTML = document.getElementById("calendar-date").value + ": New Entry";
    calendarEditForm.innerHTML = buildCalendarEditForm(-1);
    showPlannerDiv("planner-calendar-form")
}

function selectCalendarEditForm(calendarDatabaseRowIndex) {
    //show what's being edited
    calendarEditFormMessage.innerHTML = document.getElementById("calendar-date").value + ": Entry " + calendarDatabaseRowIndex.toString();
    calendarEditForm.innerHTML = buildCalendarEditForm(calendarDatabaseRowIndex);
    showPlannerDiv("planner-calendar-form");
}

function buildCalendarEditForm(index) {
    let date = document.getElementById("calendar-date").value;


    let thisEntry = calendarDatabase["data"][index];


    let editForm = "";
    editForm += "<form>";
    editForm = "<input type='hidden' id='calendar-row-index' value='" + index.toString() + "'>";
    let numberOfColumns = calendarDatabase["headers"].length;
    let headers = calendarDatabase["headers"];
    let row = thisEntry;
    let inputTypes = calendarDatabase["inputTypes"];

    //make blank form
    for (let j = 0; j < numberOfColumns; j++) {
        let extraString = "";
        if (inputTypes[headers[j]] === "number") {
            extraString = " step='any' ";
        } else if (inputTypes[headers[j]] === "tel") {
            extraString = " placeholder='304-424-1000' pattern='[0-9]{3}-[0-9]{3}-[0-9]{4}' ";
        }
        if ((headers[j] === "Start Date") && (index === -1)) { extraString = "value=" + date };
        if ((headers[j] === "End Date") && (index === -1)) { extraString = "value=" + date };
        if (headers[j] === "UID") { extraString = "disabled" };
        // ////////Added in order for UIDs not in previous data table, now loads at import
        // if (row[headers[j]]===undefined){
        //     row[headers[j]]="";
        // }
        ////////////////
        if (inputTypes[headers[j]] !== "textarea") {
            console.log("not textarea")
            if (index === -1) { //adding new
                editForm += "<div><label for='" + headers[j] + "'>" + headers[j] + "</label></div><div><input type='" + inputTypes[headers[j]] + "' id='" + headers[j] + "' " + extraString + "></div>";
            } else { //editing existing
                editForm += "<div><label for='" + headers[j] + "'>" + headers[j] + "</label></div><div><input type='" + inputTypes[headers[j]] + "' id='" + headers[j] + "' value='" + row[headers[j]].split("\"").join("&quot;").split("\'").join("&apos;") + "'" + extraString + "></div>";
            }
        } else {
            console.log("textarea!")
            if (index === -1) { //adding new
                editForm += "<div><label for='" + headers[j] + "'>" + headers[j] + "</label></div><div><textarea id='" + headers[j] + "' " + extraString + "></textarea></div>";
            } else { //editing existing
                let textAreaContents = row[headers[j]].split("\"").join("&quot;").split("\'").join("&apos;");
                console.log(textAreaContents);
                editForm += "<div><label for='" + headers[j] + "'>" + headers[j] + "</label></div><div><textarea id='" + headers[j] + "' " + extraString + ">" + textAreaContents + "</textarea></div>";
            }
        }
    }
    editForm += "</form>";
    return editForm;
}

function saveCalendarEntry() {
    let index = parseInt(document.getElementById("calendar-row-index").value);
    let date = document.getElementById("calendar-date").value;
    let headers = calendarDatabase["headers"];
    let row = {};
    //make a row to add onto array of entries
    //or
    //make a row to update the array
    for (let j = 0; j < headers.length; j++) {
        row[headers[j]] = document.getElementById(headers[j]).value;
    }
    //insist start date exists
    if (row["Start Date"] === "") {
        row["Start Date"] = date;
    }
    if (row["Start Time"] === "") {
        row["Start Time"] = "00:00";
    }
    if ((row["UID"] === "") || (row["UID"] === undefined)) {
        row["UID"] = makeUID(row["Start Date"], row["Start Time"]);
    }

    if (index >= 0) { //an existing entry
        calendarDatabase["data"][index] = row;
    } else { // a new entry
        calendarDatabase["data"].push(row);
    }
    clearCalendarFormEntries();
    //destructiveSort(calendarDatabase["data"], "sort value");
    calendarTable.innerHTML = buildCalendarTableElement(date);
    showPlannerDiv("planner-calendar-table");
    if (confirm("Current data updated.  Save updated data to file?")) {
        saveCombinedDatabase();
    }
}

function exportSingleICalEvent() {
    let index = parseInt(document.getElementById("calendar-row-index").value);
    let date = document.getElementById("calendar-date").value;
    let headers = calendarDatabase["headers"];
    let row = {};
    for (let j = 0; j < headers.length; j++) {
        row[headers[j]] = document.getElementById(headers[j]).value;
    }
    if ((row["UID"] === "") || row["UID"] === undefined) {
        row["UID"] = makeUID(row["Start Date"], row["Start Time"]);
        document.getElementById("UID").innerHTML = row["UID"];
    }
    let vEvent = makeVEvent(row, "\n");
    let eventsArr = [];
    eventsArr.push(vEvent);
    let vCal = makeVCalendar(eventsArr, "\n");
    let filename = "vEvent" + row["Start Date"] + "_" + row["Start Time"].replace(/\:/g, "");
    copyAndSaveString(vCal, filename, ".ical", mimeType = "text/calendar");


    if (index >= 0) { //an existing entry
        calendarDatabase["data"][index] = row;
    } else { // a new entry
        calendarDatabase["data"].push(row);
    }

    alert("Entry also updated in calendar.");
    clearCalendarFormEntries();
    //destructiveSort(calendarDatabase["data"], "sort value");
    calendarTable.innerHTML = buildCalendarTableElement(date);
    showPlannerDiv("planner-calendar-table");
}


function makeUID(startDate, startTime) {
    let rows = calendarDatabase["data"];
    let usedIDs = [];
    for (let i = 0; i < rows.length; i++) {
        usedIDs.push(rows[i]["UID"]);
    }

    let UID = "bitOffice." + ISOStringToICalStringZulu((htmlDateAndTimeToISOString(startDate, startTime))) + Math.random().toString();
    while (usedIDs.includes(UID)) {
        UID = "bitOffice." + ISOStringToICalStringZulu((htmlDateAndTimeToISOString(startDate, startTime))) + Math.random().toString();
    }

    return UID;

}

function purgeCalendar() {
    //let dates = calendarDatabase["dates"];
    //for (let date in dates) {
    //    console.log(date);cancelCalend
    //    console.log(dates[date]["data"]);
    //    console.log(dates[date]["data"].length);
    //    if (dates[date]["data"].length === 0) {
    //        delete dates[date];
    //    }
    //}
}

function deleteCalendarEntry() {
    let index = parseInt(document.getElementById("calendar-row-index").value);
    let date = document.getElementById("calendar-date").value;
    if (index >= 0) { //editing an entry
        if (confirm("Delete this entry?")) {
            calendarDatabase["data"].splice(index, 1);
        }
    }
    clearCalendarFormEntries();
    calendarTable.innerHTML = buildCalendarTableElement(date);
    showPlannerDiv("planner-calendar-table");
    if (confirm("Current data updated.  Save updated data to file?")) {
        saveCombinedDatabase();
    }
}

function cancelCalendarEntry() {
    let date = document.getElementById("calendar-date").value;
    clearCalendarFormEntries();
    calendarTable.innerHTML = buildCalendarTableElement(date);
    showPlannerDiv("planner-calendar-table");
}

function clearCalendarFormEntries() {
    let headers = calendarDatabase["headers"];
    for (let j = 0; j < headers.length; j++) {
        document.getElementById(headers[j]).value = "";
    }
    document.getElementById("calendar-row-index").value = -1;
    calendarEditFormMessage.innerHTML = "";
}

function sortCalendarByField(clickedHeaderElement) {
    let date = document.getElementById("calendar-date").value;
    let field = clickedHeaderElement.innerHTML;
    if (calendarDatabase["dates"][date]["data"].length > 1) { //don't sort if less than 2 rows.
        if (confirm("Sort by " + clickedHeaderElement.innerHTML + "?")) {
            destructiveSort(calendarDatabase["dates"][date]["data"], field, calendarSortAscending);
            calendarTable.innerHTML = buildCalendarTableElement(date);
            calendarSortAscending = -1 * calendarSortAscending;
        };
    }
}

function makeCalendar() {
    console.log("--------------------");
    console.log(monthChooser.value);
    console.log("--------------------");

    let d = new Date(monthChooser.value + "-01T00:00");
    let startDayIndex = d.getDay(); //zero based day
    let monthToUse = parseInt(monthChooser.value.split("-")[1]) - 1;
    let yearToUse = parseInt(monthChooser.value.split("-")[0]);
    let daysInMonth = daysInSomeMonth(monthToUse, yearToUse);

    let calendarString = "<table>";
    //header
    calendarString += "<tr><th>Sun</th><th>Mon</th><th>Tue</th><th>Wed</th><th>Thu</th><th>Fri</th><th>Sat</th></tr>";

    //start rows
    calendarString += "<tr>";

    //blank days
    //so start day is the number of loops to do conincidentally
    for (let i = 0; i < startDayIndex; i++) {
        console.log("x", daysAbbreviations[i]);
        calendarString += "<td>" + "-" + "</td>";
    }

    //days
    for (let i = 0; i < daysInMonth; i++) {
        let thisDate = i + 1; //date 1 indexed
        let thisDayOfWeek = daysAbbreviations[(i + startDayIndex) % 7];
        if ((i + startDayIndex) % 7 === 0) {
            console.log("--------new line ----------");
            calendarString += "</tr><tr>"
        }
        calendarString += "<td class='return-calendar-date'>" + (i + 1).toString() + "</td>";
        //console.log(thisDate, thisDayOfWeek);
    }

    //blank days at end
    //find out what day of week last day is on
    let lastDayIndex = (daysInMonth - 1 + startDayIndex) % 7;
    let blankSpacesRemaining = 6 - lastDayIndex;
    for (let i = 0; i < blankSpacesRemaining; i++) {
        //console.log("x", daysAbbreviations[lastDayIndex + 1 + i]);
        calendarString += "<td>" + "-" + "</td>";
    }
    calendarString += "</tr></table>";

    document.getElementById('special-calendar').innerHTML = calendarString;
    addEventListenersToCalendarEntries();
    purgeCalendar();
    colorCalendarEntries();
    return calendarString;

}

function addEventListenersToCalendarEntries() {
    let calendarEntries = document.getElementsByClassName('return-calendar-date');
    for (let entry of calendarEntries) {
        entry.addEventListener("click", (evt) => { openDayEntry(evt) });
    }
}

function openDayEntry(evt) {
    //add "0" to date then slice -2 to ensure leading 0
    let theDate = monthChooser.value + "-" + ("0" + evt.target.innerHTML).slice(-2);
    document.getElementById("calendar-date").value = theDate;
    if (theDate === "") {
        return;
    }


    //go through

    //check to see if year entry is in database, if needed make entry
    //if (calendarDatabase["dates"][theDate] === undefined) {
    //    calendarDatabase["dates"][theDate] = {};
    //    calendarDatabase["dates"][theDate]["data"] = [];
    //}

    document.getElementById("calendar-table-name").innerHTML = daysAbbreviations[getDayOfWeek(theDate)] + " " + theDate + "</span>";
    calendarTable.innerHTML = buildCalendarTableElement(theDate);
    showPlannerDiv("planner-calendar-table");
}

function colorCalendarEntries() {
    purgeCalendar();
    let calendarEntries = document.getElementsByClassName('return-calendar-date');
    for (let entry of calendarEntries) {
        entry.style["backgroundColor"] = "#E0E0E0;";
        let thisDate = monthChooser.value + "-" + ("0" + entry.innerHTML).slice(-2);
        //go through all entries in the calendar data
        for (let i = 0; i < calendarDatabase["data"].length; i++) {
            //if thisDate === calendar entry start date, color darkorange
            //if thisDate === calendar entry end date, color darkorange
            //if thisDate >= calendar entry start date and thisDate <= end date, color darkorange
            if (
                (thisDate === calendarDatabase["data"][i]["Start Date"]) ||
                (thisDate === calendarDatabase["data"][i]["End Date"]) ||
                ((thisDate >= calendarDatabase["data"][i]["Start Date"]) && (thisDate <= calendarDatabase["data"][i]["End Date"]))
            ) {
                entry.style["backgroundColor"] = "darkorange";
            }
        }

        //need to change,
        // go through all dates
        //if (calendarDatabase["dates"][thisDate] === undefined) { 
        //    entry.style["backgroundColor"] = "#E0E0E0;";
        //} else {
        //    entry.style["backgroundColor"] = "darkorange";
        //}

        if (getTodaysDate() === thisDate) {
            entry.style["border"] = "2px solid black";
            entry.style["font-weight"] = "bold";
            //entry.style["backgroundColor"] = "yellow";
        }
    }
}



function createOutlookCSV() {
    let outlookCSV = JSONToCSV(calendarDatabase, true, "\r\n");
    console.log(outlookCSV);
    copyAndSaveString(outlookCSV, "plannerToOutlookExport" + getTodaysDate(), ".csv", "text/csv");
}

function loadOutlookCSV() {
    if (confirm("This will add entries to the existing current calendar.\n\nIf you want to over-write all contents, please clear the calendar first, then proceed with loading the data.")) {
        let fileContents = "";
        let inputTypeIsFile = document.createElement('input');
        inputTypeIsFile.type = "file";
        inputTypeIsFile.accept = ".csv";
        inputTypeIsFile.addEventListener("change", function () {
            let inputFile = inputTypeIsFile.files[0];
            let fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
                fileContents = fileLoadedEvent.target.result;

                console.log(fileContents);

                let outlookCSVObject = csvToJSON(fileContents);
                console.log(outlookCSVObject);

                let outlookData = outlookCSVObject["data"];
                let headers = calendarDatabase["headers"];
                let outlookHeaders = outlookCSVObject["headers"];


                //original method
                //for (let i=0;i<outlookData.length;i++){
                //	let row={};
                //	console.log(outlookData[i]);
                //	for (let j=0;j<headers.length;j++){
                //		if ((headers[j]==="Start Date")||(headers[j]==="End Date")){
                //			row[headers[j]]=outlookDateToPlannerDate(outlookData[i][headers[j]]);
                //		}
                //		else if((headers[j]==="Start Time")||(headers[j]==="End Time")){
                //			row[headers[j]]=outlookTimeToPlannerTime(outlookData[i][headers[j]]);
                //		}
                //		else{
                //			row[headers[j]]=outlookData[i][headers[j]];
                //		}	
                //	}	
                //	calendarDatabase["data"].push(row);
                //}

                //new method
                for (let i = 0; i < outlookData.length; i++) {
                    let row = {};
                    console.log(outlookData[i]);
                    //for any row, convert dates and times to html input type=date format
                    for (let j = 0; j < headers.length; j++) {
                        if ((headers[j] === "Start Date") || (headers[j] === "End Date")) {
                            row[headers[j]] = outlookDateToPlannerDate(outlookData[i][headers[j]]);
                        }
                        else if ((headers[j] === "Start Time") || (headers[j] === "End Time")) {
                            row[headers[j]] = outlookTimeToPlannerTime(outlookData[i][headers[j]]);
                        }
                        else {
                            row[headers[j]] = outlookData[i][headers[j]];
                        }
                    }
                    //any header that is in outlook csv data but not a planner heading is added to Description
                    let addOnString = "\nAdditional Information:\n_______________________";
                    for (let j = 0; j < outlookHeaders.length; j++) {
                        //console.log("XXXXXXXXXXXXXXXXXX "+outlookHeaders[j]+":"+outlookData[i][outlookHeaders[j]]);
                        if (row.hasOwnProperty(outlookHeaders[j])) {
                            //do nothing
                        }
                        else {
                            if ((outlookData[i][outlookHeaders[j]].trim() !== "") && (outlookData[i][outlookHeaders[j]].trim() !== "Normal")) {//check to make sure that field is not empty 
                                //row["Description"]+="\r\n"+outlookHeaders[j]+":"+outlookData[i][outlookHeaders[j]];
                                addOnString += "\n" + outlookHeaders[j] + ":" + outlookData[i][outlookHeaders[j]];
                            }
                        }
                    }

                    if (addOnString !== "\nAdditional Information:\n_______________________") {

                        row["Description"] += addOnString.trim();//
                        row["Description"] = row["Description"].trim();
                    }
                    //now add all properties that are not under heading and concatenate to description in key val pairs


                    calendarDatabase["data"].push(row);
                }

                //go through each row and add a value called "sort value" for sorting data when needed, consists of startdate followed by start time.
                //"sort value" is not added to header, as it is used in the program but not for display saving etc.

                //when data is loaded in or changed, sort value is added and calendar always sorted
                //addSortValueToCalendarData();
                //destructiveSort(calendarDatabase["data"], "sort value");
                ////////////////////


                //calendarTable.innerHTML = buildCalendarTableElement(date);
                showPlannerDiv("planner-calendar-start");
                makeCalendar();
            };
            fileReader.readAsText(inputFile, "UTF-8");
        });
        inputTypeIsFile.click();
        console.log("loadOutlookCSV called");
    }

}
// function addSortValueToCalendarData() {
//     for (let i = 0; i < calendarDatabase["data"].length; i++) {
//         let row = calendarDatabase["data"][i];

//         //insist start date exists
//         if ((row["Start Date"] === "") || (row["Start Date"] === undefined)) {
//             row["Start Date"] = "1970-01-01";
//         }
//         if ((row["Start Time"] === "") || (row["Start Time"] === undefined)) {
//             row["Start Time"] = "00:00";
//         }

//         calendarDatabase["data"][i]["sort value"] = row["Start Date"] + row["Start Time"];
//     }
// }


function outlookDateToPlannerDate(outlookDate) {
    let outlookData = outlookDate.trim().split("/");

    if (outlookData.length !== 3) {
        return outlookDate;
    }
    let month = ("0" + outlookData[0]).slice(-2);
    let day = ("0" + outlookData[1]).slice(-2);
    let year = outlookData[2];

    console.log(outlookDate);
    console.log(outlookData);

    let plannerDate = year + "-" + month + "-" + day;
    console.log(plannerDate);
    return plannerDate;
}

function outlookTimeToPlannerTime(outlookTime) {

    //input format is "8:20:00 PM"
    //output format is "20:00"
    //	leading 0 must be added
    //	add 12 to PM hours
    //	only report hour and minutes

    let PM = false;
    if (outlookTime.indexOf("PM") != -1) {
        //alert("has PM!");
        PM = true;
    }

    let outlookData = outlookTime.split(":");

    if (!(outlookData.length >= 2)) { return outlookTime };//not parsing right for sure

    let strHour = outlookData[0];
    let intHour = parseInt(strHour);

    //add 12 hours if needed
    if ((PM === true) && (intHour !== 12)) {
        intHour += 12;
    }

    strHour = intHour.toString();//convert back to string
    strHour = ("0" + strHour).slice(-2);//add leading 0 if needed

    let minutes = outlookData[1];

    return strHour + ":" + minutes;

}


function clearCalendar() {
    if (confirm("Are you sure?  This will clear all calendar entries")) {
        calendarDatabase = {
            "name": "Calendar",
            "headers": ["Subject", "Start Date", "Start Time", "End Date", "End Time", "Description", "UID"],
            "inputTypes": {
                "Subject": "text",
                "Start Date": "date",
                "Start Time": "time",
                "End Date": "date",
                "End Time": "time",
                "Description": "textarea",
                "UID": "text"
            },
            "data": []
        }
    }
    makeCalendar();
}

////////////////////CONTACTS/////////////////////////

initializeContactsApp();

function initializeContactsApp() {
    fillInEmptyPropertyValues(contactsTable);
    //document.getElementById("contacts-table-name").innerHTML = contactsTable["name"];
    contactsTableElement.innerHTML = buildContactsTableElement(contactsTable);
    contactsEditForm.innerHTML = buildContactsEditForm(contactsTable, -1);
}

function backupContactsDatabase() {
    return JSON.parse(JSON.stringify(contactsTable));
}

function buildContactsTableElement(contactsTable) {
    let tableElement = "";
    let numberOfColumns = contactsTable["headers"].length;
    //numberOfColumns = 2; //only showing first 3
    let numberOfRows = contactsTable["data"].length;

    //start contactsTable
    tableElement += "<table>";

    //build table header
    tableElement += "<thead><tr>";
    for (let j = 0; j < numberOfColumns; j++) {
        tableElement += "<th onclick='sortContactsByField(this);'>" + contactsTable["headers"][j] + "</th>";
    }
    tableElement += "</tr></thead>";

    //build table body	
    tableElement += "<tbody>";

    for (let i = 0; i < numberOfRows; i++) {
        tableElement += "<tr id='contacts-table-row-" + i.toString() + "' onclick='selectContactsEditForm(this)'>";
        for (let j = 0; j < numberOfColumns; j++) {
            let fieldName = contactsTable["headers"][j];
            //console.log(contactsTable["data"][i][fieldName]);
            tableElement += "<td><pre>" + contactsTable["data"][i][fieldName] + "</pre></td>";
        }
        tableElement += "</tr>";
    }
    tableElement += "</tbody>";

    return tableElement;
}

function newContactsEntry() {
    //show what's being edited
    contactsEditFormMessage.innerHTML = contactsTable["name"] + ": New Entry";
    contactsEditForm.innerHTML = buildContactsEditForm(contactsTable, -1);
    showPlannerDiv("planner-contacts-form");
}

function selectContactsEditForm(clickedRow) {
    //show what's being edited
    let index = parseInt(clickedRow.id.split("-")[3]);
    contactsEditFormMessage.innerHTML = contactsTable["name"] + ": Entry " + index.toString();
    contactsEditForm.innerHTML = buildContactsEditForm(contactsTable, index);
    showPlannerDiv("planner-contacts-form");
}

function buildContactsEditForm(contactsTable, index) {
    let editForm = "";
    editForm += "<form>";
    editForm = "<input type='hidden' id='contacts-row-index' value='" + index.toString() + "'>";
    let numberOfColumns = contactsTable["headers"].length;
    let headers = contactsTable["headers"];
    let row = contactsTable["data"][index];
    let inputTypes = contactsTable["inputTypes"];

    //make blank form
    for (let j = 0; j < numberOfColumns; j++) {
        let extraString = "";
        if (inputTypes[headers[j]] === "number") {
            extraString = " step='any' ";
        } else if (inputTypes[headers[j]] === "tel") {
            extraString = " placeholder='304-424-1000' pattern='[0-9]{3}-[0-9]{3}-[0-9]{4}' ";
        }
        if (index === -1) { //adding new
            if (inputTypes[headers[j]] === "textarea") {
                //handle text area
                editForm += "<div><label for='contact-" + headers[j] + "'>" + headers[j] + "</label></div><div><textarea id='contact-" + headers[j] + "' " + extraString + "></textarea></div>";
            } else {
                editForm += "<div><label for='contact-" + headers[j] + "'>" + headers[j] + "</label></div><div><input type='" + inputTypes[headers[j]] + "' id='contact-" + headers[j] + "' " + extraString + "></div>";
            }
        } else { //editing existing
            if (inputTypes[headers[j]] === "textarea") {
                //handle text area
                let textAreaContents = row[headers[j]].split("\"").join("&quot;").split("\'").join("&apos;");
                editForm += "<div><label for='contact-" + headers[j] + "'>" + headers[j] + "</label></div><div><textarea id='contact-" + headers[j] + "' " + extraString + ">" + textAreaContents + "</textarea></div>";
            } else {

                editForm += "<div><label for='contact-" + headers[j] + "'>" + headers[j] + "</label></div><div><input type='" + inputTypes[headers[j]] + "' id='contact-" + headers[j] + "' value='" + row[headers[j]].split("\"").join("&quot;").split("\'").join("&apos;") + "'" + extraString + "></div>";
            }
        }
    }
    editForm += "</form>";
    return editForm;
}

function saveContactsEntry() {
    let index = parseInt(document.getElementById("contacts-row-index").value);
    //console.log(index);
    let headers = contactsTable["headers"];
    let row = {};
    for (let j = 0; j < headers.length; j++) {
        row[headers[j]] = document.getElementById("contact-" + headers[j]).value;
    }
    if (index >= 0) { //an existing entry
        contactsTable["data"][index] = row;
    } else { // a new entry
        contactsTable["data"].push(row);
    }
    clearContactFormEntries(contactsTable);
    contactsTableElement.innerHTML = buildContactsTableElement(contactsTable);
    showPlannerDiv("planner-contacts-table");

    if (confirm("Data updated.  Save updated data to file?")) {
        saveCombinedDatabase();
    }
}

function exportSingleVCard() {
    let index = parseInt(document.getElementById("contacts-row-index").value);
    //console.log(index);
    let headers = contactsTable["headers"];
    let row = {};
    for (let j = 0; j < headers.length; j++) {
        row[headers[j]] = document.getElementById("contact-" + headers[j]).value;
    }

    let vCard = makeSingleVCFString(row);

    copyAndSaveString(vCard, row["First Name"] + "-" + row["Last Name"] + "-" + "Contact" + "-" + getTodaysDate(), ".vcf", "text/vcard");

    if (index >= 0) { //an existing entry
        contactsTable["data"][index] = row;
    } else { // a new entry
        contactsTable["data"].push(row);
    }
    alert("Entry also updated in contacts.");

    clearContactFormEntries(contactsTable);
    contactsTableElement.innerHTML = buildContactsTableElement(contactsTable);
    showPlannerDiv("planner-contacts-table");
}

function deleteContactsEntry() {
    let index = parseInt(document.getElementById("contacts-row-index").value);
    if (index >= 0) { //editing an entry
        if (confirm("Delete this entry?")) {
            contactsTable["data"].splice(index, 1); //an object
        }
    }
    clearContactFormEntries(contactsTable);
    contactsTableElement.innerHTML = buildContactsTableElement(contactsTable);
    showPlannerDiv("planner-contacts-table");
    if (confirm("Current data updated.  Save updated data to file?")) {
        saveCombinedDatabase();
    }
}

function cancelContactsEntry() {
    clearContactFormEntries(contactsTable);
    contactsTableElement.innerHTML = buildContactsTableElement(contactsTable);
    showPlannerDiv("planner-contacts-table");
}


function clearContactFormEntries(contactsTable) {
    let headers = contactsTable["headers"];
    for (let j = 0; j < headers.length; j++) {
        document.getElementById("contact-" + headers[j]).value = "";
    }
    document.getElementById("contacts-row-index").value = -1;
    contactsEditFormMessage.innerHTML = "";
}

function sortContactsByField(clickedHeaderElement) {
    let field = clickedHeaderElement.innerHTML;
    if (contactsTable["data"].length > 1) {
        if (confirm("Sort by " + clickedHeaderElement.innerHTML + "?\n\nThis cannot be undone.")) {
            destructiveSort(contactsTable["data"], field, contactsSortAscending);
            contactsTableElement.innerHTML = buildContactsTableElement(contactsTable);
            contactsSortAscending = -1 * contactsSortAscending;
        }
    }
}



function loadOutlookContactsCSV() {
    if (confirm("This will merge entries.\n\nIf you want to over-write all contents, please clear the contacts first, then proceed with loading the data.")) {
        let fileContents = "";
        let inputTypeIsFile = document.createElement('input');
        inputTypeIsFile.type = "file";
        inputTypeIsFile.accept = ".csv";
        inputTypeIsFile.addEventListener("change", function () {
            let inputFile = inputTypeIsFile.files[0];
            let fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
                fileContents = fileLoadedEvent.target.result;

                console.log(fileContents);

                let outlookCSVObject = csvToJSON(fileContents);
                console.log(outlookCSVObject);

                let outlookData = outlookCSVObject["data"];
                let headers = contactsTable["headers"];
                let outlookHeaders = outlookCSVObject["headers"];

                //original method
                //for (let i=0;i<outlookData.length;i++){
                //	let row={};
                //	console.log(outlookData[i]);
                //	for (let j=0;j<headers.length;j++){
                //		if ((headers[j]==="Start Date")||(headers[j]==="End Date")){
                //			row[headers[j]]=outlookDateToPlannerDate(outlookData[i][headers[j]]);
                //		}
                //		else if((headers[j]==="Start Time")||(headers[j]==="End Time")){
                //			row[headers[j]]=outlookTimeToPlannerTime(outlookData[i][headers[j]]);
                //		}
                //		else{
                //			row[headers[j]]=outlookData[i][headers[j]];
                //		}	
                //	}	
                //	calendarDatabase["data"].push(row);
                //}

                //new method
                for (let i = 0; i < outlookData.length; i++) {
                    let row = {};
                    console.log(outlookData[i]);
                    for (let j = 0; j < headers.length; j++) {
                        row[headers[j]] = outlookData[i][headers[j]];
                    }
                    let addOnString = "\r\nAdditional Information:\r\n_______________________";
                    for (let j = 0; j < outlookHeaders.length; j++) {
                        console.log(outlookHeaders[j]);
                        if (row.hasOwnProperty(outlookHeaders[j])) {
                            //alert("has own property"+outlookHeaders[i]);
                        }
                        else {
                            if ((outlookData[i][outlookHeaders[j]].trim() === "") || (outlookHeaders[j].trim() === "Categories")) {
                                //do nothing
                            } else {
                                addOnString += "\r\n" + outlookHeaders[j] + ":" + outlookData[i][outlookHeaders[j]];
                                console.log("extra: " + outlookHeaders[j] + "\n" + outlookData[i][outlookHeaders[j]]);
                            }

                        }
                    }
                    if (addOnString === "\r\nAdditional Information:\r\n_______________________") {//no changes made
                        //do nothing
                        row["Notes"] = row["Notes"].trim();
                    } else {//changes made, add on to description
                        row["Notes"] = row["Notes"].trim();
                        //now add all properties that are not under heading and concatenate to description in key val pairs
                        row["Notes"] += "\r\n" + addOnString;
                    }
                    contactsTable["data"].push(row);
                }

                contactsTableElement.innerHTML = buildContactsTableElement(contactsTable);
                showPlannerDiv("planner-contacts-table");
                //makeCalendar();
            };
            fileReader.readAsText(inputFile, "UTF-8");
        });
        inputTypeIsFile.click();
        console.log("loadOutlookContactsCSV called");
    }
}

function saveOutlookContactsCSV() {
    let thisCSV = makeCSV(contactsTable, true);
    copyAndSaveString(thisCSV, contactsTable["name"] + getTodaysDate(), ".csv", "text/csv");
}

function importVCF() {
    if (confirm("This will merge entries.\n\nIf you want to over-write all contents, please clear the contacts first, then proceed with loading the data.")) {
        let fileContents = "";
        let inputTypeIsFile = document.createElement('input');
        inputTypeIsFile.type = "file";
        inputTypeIsFile.accept = ".vcf";
        inputTypeIsFile.addEventListener("change", function () {
            let inputFile = inputTypeIsFile.files[0];
            let fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
                fileContents = fileLoadedEvent.target.result;
                readInAllVcards(fileContents);
                contactsTableElement.innerHTML = buildContactsTableElement(contactsTable);
                showPlannerDiv("planner-contacts-table");
                //makeCalendar();
            };
            fileReader.readAsText(inputFile, "UTF-8");
        });
        inputTypeIsFile.click();
    }
}

function importICSCalendar() {
    if (confirm("This will merge entries.  Continue?")) {
        let fileContents = "";
        let inputTypeIsFile = document.createElement('input');
        inputTypeIsFile.type = "file";
        inputTypeIsFile.accept = ".ics";
        inputTypeIsFile.addEventListener("change", function () {
            let inputFile = inputTypeIsFile.files[0];
            let fileReader = new FileReader();
            fileReader.onload = function (fileLoadedEvent) {
                fileContents = fileLoadedEvent.target.result;

                let events = getVEVENTSFromICS(fileContents);
                for (let i = 0; i < events.length; i++) {
                    let row = parseVEVENTToObject(events[i]);

                    if ((row["UID"] === "") || (row["UID"]) === undefined) {
                        row["UID"] = makeUID(row["Start Date"], row["Start Time"]);
                    }
                    calendarDatabase["data"].push(row);
                }
                showPlannerDiv('planner-calendar-start');
                makeCalendar();
                // readInAllVcards(fileContents);
                // contactsTableElement.innerHTML = buildContactsTableElement(contactsTable);
                // showPlannerDiv("planner-contacts-table");

            };
            fileReader.readAsText(inputFile, "UTF-8");
        });
        inputTypeIsFile.click();
    }

}

function getVEVENTSFromICS(contents) {
    contents.replace(/(\r\n|\r|\n)/g, "\\\n");
    contents = contents.trim();
    lines = contents.split("\n");
    let events = [];
    let str = "";
    let inside = false;
    for (let i = 0; i < lines.length; i++) {
        if (inside === true) {
            if (lines[i].slice(0, 10) === "END:VEVENT") {
                inside = false;
                events.push(str);
                str = "";
            }
            else {
                str += lines[i] += "\n";
            }
        }
        if ((lines[i].slice(0, 12)) === "BEGIN:VEVENT") {
            inside = true;
        }
    }
    return events;
}

function parseVEVENTToObject(vEvent) {
    let row = {}
    //Just in case
    vEvent = vEvent.replace(/(\r\n|\r|\n)/g, "\n");
    vEvent = vEvent.trim();
    let lines = vEvent.split("\n");
    row["Subject"] = "";
    row["Description"] = "";
    row["UID"] = "";
    row["Start Date"] = "";
    row["Start Time"] = "";
    row["End Date"] = "";
    row["End Time"] = "";
    let extraStuff = "\n-------Extra Stuff-------\n";
    for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        if (line.slice(0, 7) === "SUMMARY") {
            row["Subject"] = line.split(":")[1];
        }
        else if (line.slice(0, 11) === "DESCRIPTION") {
            row["Description"] = line.split(":")[1];
        }
        else if (line.slice(0, 3) === "UID") {
            row["UID"] = line.split(":")[1];
        }
        else if (line.slice(0, 7) === "DTSTART") {
            let iCalStartDate = line.split(":")[1];
            let ISOString = iCalDateToISOString(iCalStartDate);
            let startDateObject = new Date(ISOString);
            let year = startDateObject.getFullYear().toString();
            let month = ("0" + ((startDateObject.getMonth() + 1).toString())).slice(-2);
            let date = ("0" + (startDateObject.getDate().toString())).slice(-2);
            //let hours = ("0" + ((startDateObject.getHours() + 1).toString())).slice(-2);
            let hours = ("0" + (startDateObject.getHours().toString())).slice(-2);
            let minutes = ("0" + (startDateObject.getMinutes().toString())).slice(-2);
            let seconds = ("0" + (startDateObject.getSeconds().toString())).slice(-2);
            console.log("year: ", year, " month: ", month, " date: ", date);
            console.log("hours: ", hours, " minutes: ", minutes, " seconds: ", seconds);
            row["Start Date"] = year + "-" + month + "-" + date;

            /////////////**********This is where seconds are added in when reading in */
            row["Start Time"] = hours + ":" + minutes;// + ":" + seconds;
        }
        else if (line.slice(0, 5) === "DTEND") {
            let iCalEndDate = line.split(":")[1];
            let ISOString = iCalDateToISOString(iCalEndDate);
            let endDateObject = new Date(ISOString);
            let year = endDateObject.getFullYear().toString();
            let month = ("0" + ((endDateObject.getMonth() + 1).toString())).slice(-2);
            let date = ("0" + (endDateObject.getDate().toString())).slice(-2);
            //let hours = ("0" + ((endDateObject.getHours() + 1).toString())).slice(-2);
            let hours = ("0" + (endDateObject.getHours().toString())).slice(-2);
            let minutes = ("0" + (endDateObject.getMinutes().toString())).slice(-2);
            let seconds = ("0" + (endDateObject.getSeconds().toString())).slice(-2);
            row["End Date"] = year + "-" + month + "-" + date;
            /////////////**********This is where seconds are added in when reading in */            
            row["End Time"] = hours + ":" + minutes;// + ":" + seconds;
        }
        else {
            extraStuff += line + "\n";
        }
    }

    row["Description"] += extraStuff;
    // need SUMMARY
    // need DTSTART
    // need DTEND
    // need DESCRIPTION
    // need UID
    return row;
}

function iCalDateToISOString(icalDate) {
    let year = icalDate.slice(0, 4);
    let month = icalDate.slice(4, 6);
    let day = icalDate.slice(6, 8);
    let hour = "00";
    let min = "00";
    let sec = "00";
    if (icalDate.indexOf("T") !== -1) {//Long String
        hour = icalDate.slice(9, 11);
        min = icalDate.slice(11, 13);
        sec = icalDate.slice(13, 15);
    }
    if (icalDate.indexOf("Z") !== -1) {
        let ISOString = year + "-" + month + "-" + day + "T" + hour + ":" + min + ":" + sec + ".000Z";
        return ISOString;
    }
    else {
        let intYear=parseInt(year);
        let intMonth = parseInt(month);
        let intDay=parseInt(day);
        let intHour=parseInt(hour);
        let intMin=parseInt(min);
        let intSec=parseInt(sec);
        let dateObject = new Date(intYear, intMonth - 1, intDay, intHour, intMin, intSec);
        return dateObject.toISOString();
    }
}

function readInAllVcards(contents) {
    let startIndex = contents.indexOf("BEGIN:VCARD");
    let endIndex = contents.indexOf("END:VCARD");
    while (startIndex !== -1) {
        let vCard = contents.substring(startIndex, endIndex + 9);
        let contactObject = parseContactFromVCard(vCard);
        contactsTable["data"].push(contactObject);
        startIndex = contents.indexOf("BEGIN:VCARD", endIndex);
        endIndex = contents.indexOf("END:VCARD", startIndex + 1);
    };
}

function parseContactFromVCard(vCard) {
    vCard = vCard.trim();
    vCard = vCard.replace(/;PREF/g, "");
    vCard = vCard.replace(/;VOICE/g, ";HOME");
    vCard = vCard.replace(/\r\n|\n|\r/gm, "\n");
    let lines = vCard.split("\n");
    let prefixes = ["ADR;HOME:", "EMAIL:", "FN:", "NOTE:", "TEL;CELL:", "TEL;HOME:", "TEL;WORK:", "N:"];
    let contactObjectKeys = ["Home Address", "E-mail Address", "First Name", "Notes", "Mobile Phone", "Home Phone", "Business Phone", "Last Name", "Middle Name"];
    let contactObject = {};
    for (let i = 0; i < prefixes.length; i++) {
        for (j = 0; j < lines.length; j++) {
            console.log(lines[j].substring(0, 3));
            if (lines[j].substring(0, 3) === "TEL") {// will place any telephone numer under cell, then overwritten if cell listed

                ////////////// SHOULD CHANGE OTHER TELEPHONE STUFF TO LOOK FOR HOME AND WORK 
                console.log("FOUND TEL!!!!");
                if (lines[j].indexOf("CELL") !== -1) {
                    console.log("Contains CELL");
                    contactObject["Mobile Phone"] = lines[j].split(":")[1];
                }
                if (lines[j].indexOf("HOME") !== -1) {
                    console.log("Contains HOME");
                    contactObject["Home Phone"] = lines[j].split(":")[1];
                }
                if (lines[j].indexOf("WORK") !== -1) {
                    console.log("Contains WORK");
                    contactObject["Business Phone"] = lines[j].split(":")[1];
                }
            }
            if (lines[j].substring(0, prefixes[i].length) === prefixes[i]) {
                if (prefixes[i] === "N:") {
                    let lastName = lines[j].substring(prefixes[i].length).split(";")[0];
                    //console.log("Last Name is " + lastName);
                    //if ((lastName!==undefined)&&(lastName!=="")){
                    contactObject["Last Name"] = lastName;
                    //}
                    let middleName = lines[j].substring(prefixes[i].length).split(";")[2];
                    //console.log("Middle Name is " + middleName);
                    //if ((middleName!==undefined)&&(middleName!=="")){
                    contactObject["Middle Name"] = middleName;
                    //}
                    let firstName = lines[j].substring(prefixes[i].length).split(";")[1];
                    //console.log("Middle Name is " + middleName); 
                    //if ((firstName!==undefined)&&(firstName!=="")){
                    contactObject["First Name"] = firstName;
                    //}
                }
                else {
                    console.log("found match for ", prefixes[i],);
                    // if (prefixes[i]==="FN:"){// only use first name from FN if it has not been defined from N
                    //     if ((contactObject["First Name"]=== undefined)||(contactObject["First Name"].trim()=== "")){
                    //         contactObject["First Name"] = lines[j].substring(3);//start after "FN:"
                    //     }
                    // }
                    // else
                    {
                        contactObject[contactObjectKeys[i]] = lines[j].substring(prefixes[i].length);
                    }
                }
            }
        }
    }
    //if N data is present, convert it to first name
    //


    let headers = contactsTable["headers"];
    for (let i = 0; i < headers.length; i++) {
        if (contactObject.hasOwnProperty(headers[i])) {
            //do nothing
        }
        else {
            contactObject[headers[i]] = "";
        }
    }


    let extras = ["ADR", "AGENT", "ANNIVERSARY", "BDAY", "CALADRURI", "CALURI", "CATEGORIES", "CLASS", "CLIENTPIDMAP", "FBURL", "GENDER", "GEO", "IMPP", "KEY", "KIND", "LABEL", "LANG", "MAILER", "MEMBER", "NAME", "NICKNAME", "ORG", "PRODID", "PROFILE", "RELATED", "REV", "ROLE", "SORT-STRING", "SOURCE", "TEL", "TITLE", "TZ", "UID", "URL", "XML"];
    for (let i = 0; i < lines.length; i++) {
        if (prefixes.includes(lines[i].split(":")[0] + ":")) {
            //do nothing, move to next line
        }
        else {
            for (j = 0; j < extras.length; j++) {
                if (lines[i].substring(0, extras[j].length) === extras[j]) {
                    console.log("found extra ", extras[j]);
                    contactObject["Notes"] += "\n" + extras[j] + lines[i].substring(extras[j].length);
                }
            }
        }
    }
    return contactObject;
}

//All vCards begin with 
//BEGIN:VCARD
//VERSION:
//END:VCARD. All vCards must contain the VERSION property, which specifies the vCard version. VERSION must come immediately after BEGIN, except in the vCard 2.1 standard, which allows it to be anywhere in the vCard. Otherwise, properties can be defined in any order.
function exportVCF() {
    let str = "";
    let rows = contactsTable["data"];
    for (let i = 0; i < rows.length; i++) {
        str += makeSingleVCFString(rows[i]);
    }
    console.log(str);
    copyAndSaveString(str, "vcf" + contactsTable["name"] + getTodaysDate(), ".vcf", "text/vcard");
}



function makeSingleVCFString(row) {
    let str = "";
    console.log(row);
    str += "BEGIN:VCARD\n";
    str += "VERSION:2.1\n";
    //let prefixes = ["ADR;HOME:", "EMAIL:", "FN:", "NOTE:", "TEL;CELL:", "TEL;HOME:", "TEL;WORK:", "N:"];
    //let contactObjectKeys = ["Home Address", "E-mail Address", "First Name", "Notes", "Mobile Phone", "Home Phone", "Business Phone", "Last Name", "Middle Name"];
    let familyName = "";
    let givenName = "";
    let middleName = "";
    if (row["Last Name"] !== undefined) {
        familyName = row["Last Name"];
        familyName = familyName.replace(/\;/g, " ");//remove ; because will throw off format, prevents user injection of ;
    }
    if (row["First Name"] !== undefined) {
        givenName = row["First Name"];
        givenName = givenName.replace(/\;/g, " ");
    }
    if (row["Middle Name"] !== undefined) {
        middleName = row["Middle Name"];
        middleName = middleName.replace(/\;/g, " ");
    }
    str += "N:" + familyName + ";" + givenName + ";" + middleName + ";;\n"
    //if (givenName.trim()!==""){
    str += "FN:" + givenName + " " + middleName + " " + familyName + "\n";
    //}

    if ((row["Mobile Phone"] !== undefined) && (row["Mobile Phone"] !== "")) {
        str += "TEL;CELL:" + row["Mobile Phone"] + "\n";
    }
    if ((row["Home Phone"] !== undefined) && (row["Home Phone"] !== "")) {
        str += "TEL;HOME:" + row["Home Phone"] + "\n";
    }
    if ((row["Business Phone"] !== undefined) && (row["Business Phone"] !== "")) {
        str += "TEL;WORK:" + row["Business Phone"] + "\n";
    }
    if ((row["E-mail Address"] !== undefined) && (row["E-mail Address"] !== "")) {
        str += "EMAIL:" + row["E-mail Address"] + "\n";
    }
    if ((row["Home Address"] !== undefined) && (row["Home Address"] !== "")) {
        str += "ADR;HOME:" + row["Home Address"] + "\n";
    }
    if ((row["Notes"] !== undefined) && (row["Notes"] !== "")) {
        str += "NOTE:" + row["Notes"] + "\n";
    }
    str += "END:VCARD\n";
    return str;
}

///////////////// PLANNER /////////////////////
function showPlannerDiv(id) {
    //console.log("show mains called with " + id);
    let divs = document.getElementsByClassName('planner-div');
    for (let div of divs) {
        div.style.display = "none";
    }
    document.getElementById(id).style.display = "unset";
    //document.getElementById("planner-ribbon").style.display="none";
    //document.getElementById("back-home-nav").style.display="flex";
}

function backHomePlanner() {
    showPlannerDiv("planner-home");
    document.getElementById("planner-ribbon").style.display = "flex";
    document.getElementById("back-home-nav").style.display = "none";
}

function loadCombinedDatabase() {
    let fileContents = "";
    let inputTypeIsFile = document.createElement('input');
    inputTypeIsFile.type = "file";
    inputTypeIsFile.accept = ".json";
    inputTypeIsFile.addEventListener("change", function () {
        let inputFile = inputTypeIsFile.files[0];
        let fileReader = new FileReader();
        fileReader.onload = function (fileLoadedEvent) {
            fileContents = fileLoadedEvent.target.result;
            combinedDatabase = JSON.parse(fileContents);
            //compareCombinedDatabase = JSON.stringify(combinedDatabase);
            contactsTable = combinedDatabase["contacts"];
            calendarDatabase = combinedDatabase["calendar"];

            /////////////////////////////////////////////////
            // IF OLD DATABASE DOESN'T HAVE UIDS
            if (calendarDatabase["headers"].includes("UID")) {
                //do nothing
            }
            else {
                calendarDatabase["headers"].push("UID");
                calendarDatabase["inputTypes"]["UID"] = "text";
            }
            // IF OLD DATABASE ROWS don't all have UIDS, make them now
            let dataRows = calendarDatabase["data"];
            for (let i = 0; i < dataRows.length; i++) {
                if ((dataRows[i]["UID"] === "") || (dataRows[i]["UID"] === undefined)) {
                    dataRows[i]["UID"] = makeUID(dataRows["Start Date"], dataRows["Start Time"]);
                }
            }
            /////////////////////////////////////

            clearContactFormEntries(contactsTable);
            contactsTableElement.innerHTML = buildContactsTableElement(contactsTable);
            makeCalendar();
            //backHomePlanner();
            showPlannerDiv('planner-calendar-start');
        };

        fileReader.readAsText(inputFile, "UTF-8");
    });
    inputTypeIsFile.click();
}

function saveCombinedDatabase() {
    purgeCalendar();
    let str = JSON.stringify(combinedDatabase);
    let baseFilename = "bitOfficePlanner" + getTodaysDate();
    //copyAndSaveString(str, baseFilename, ".bof");
    saveStringToTextFile(str, baseFilename, ".json", "application/json");
}


///////////////// ICal functionality //////////////////// 

function makeVEvent(row, lineTerminator = "\n") {
    let lt = lineTerminator;
    str = "";
    let subject = row["Subject"];
    let startDate = row["Start Date"];
    let UID = row["UID"];
    if ((startDate === "") || (startDate === undefined)) {
        return;
    }
    let startTime = row["Start Time"];
    if ((startTime === "") || (startTime === undefined)) {
        startTime = "00:00";
    }
    let endDate = row["End Date"];
    if ((endDate === "") || (endDate === undefined)) {
        endDate = startDate;
    }
    let endTime = row["End Time"];
    if ((endTime === "") || (endTime === undefined)) {
        endTime = startTime;
    }
    if ((UID === "") || (UID === undefined)) {
        UID = makeUID(startDate, startTime);
    }
    let description = row["Description"];
    let nowDate = new Date();
    let nowString = nowDate.toISOString();
    nowString = ISOStringToICalStringZulu(nowString);
    str += "BEGIN:VEVENT" + lt;
    str += "SUMMARY:" + subject.trim() + lt;
    //need function that goes from row to standard output
    rowDateTimeToICALString(startDate, startTime);
    rowDateTimeToICALString(endDate, endTime);
    //str += "DTSTART:" + ISOStringToICalString(htmlDateAndTimeToISOString(startDate, startTime)).trim() + lt;
    str += "DTSTART:" + rowDateTimeToICALString(startDate, startTime).trim() + lt;
    //str += "DTEND:" + ISOStringToICalString(htmlDateAndTimeToISOString(endDate, endTime)).trim() + lt;
    str += "DTEND:" + rowDateTimeToICALString(endDate, endTime).trim() + lt;
    str += "DESCRIPTION:" + description.trim() + lt;
    str += "DTSTAMP:" + nowString.trim() + lt;
    str += "UID:" + UID.trim() + lt;
    str += "END:VEVENT";

    return str;
    // DTSTART;TZID=America/New_York:20130802T103400
    // DTEND;TZID=America/New_York:20130802T110400
    // DESCRIPTION: Access-A-Ride to 900 Jay St.\, Brooklyn
    // END:VEVENT
}

function rowDateTimeToICALString(date, time) {

    //let year=parseInt(date.split("-")[0]);
    //let month=parseInt(      date.split("-")[1]      )-1;
    //let day=parseInt(date.split("-")[2]);
    //let hour=parseInt(time.split(":")[0]);
    //let min=parseInt(time.split(":")[0]);
    //let sec=parseInt(time.split(":")[0]);

    //let thisDate=new Date(year,month,day,hour,min,sec);

    //let thisDateISO=thisDate.toISOString();
    let thisDateISO = htmlDateAndTimeToISOString(date, time);
    let icalString = ISOStringToICalStringZulu(thisDateISO);

    return icalString;

    console.log("fromhtml:");

    icalStr = date.split("-").join("") + "T" + time.split(":").join("");
    console.log(icalStr);
    return icalStr;
}

function htmlDateAndTimeToISOString(date = "2023-01-31", time) {
    if ((time === "") || (time === undefined)) {
        time = "00:00";
    }
    let year = parseInt(date.slice(0, 4));
    let month = parseInt(date.slice(5, 7)) - 1;
    let day = parseInt(date.slice(8));
    let hour = parseInt(time.slice(0, 2));
    let min = parseInt(time.slice(3));
    let d = new Date(year, month, day, hour, min);
    console.log("html date and time to iso string here !!!!", d.toISOString());
    return (d.toISOString());
}

function ISOStringToICalStringZulu(ISOString) {
    // 2023-06-11T14:05:25.003Z----->20230611T140525Z
    //let ICALSTRING=ISOString.replace(/\-/,)
    let ICALString = ISOString.replace(/\.\d\d\dZ/, "Z").replace(/\-|\:|\./g, "");
    //console.log("ICALSTRING",ICALString);
    return ICALString;

}

function makeVEventsArr(dataRows) {
    let arr = [];
    for (let i = 0; i < dataRows.length; i++) {
        arr.push(makeVEvent(dataRows[i]).trim());
    }
    return arr;
}


function makeVCalendar(vEventsArr, lineTerminator = "\n") {
    let str = "";
    let lt = lineTerminator;
    str += "BEGIN:VCALENDAR" + lt;
    str += "VERSION:2.0" + lt;
    str += "PRODID:bitOffice" + lt;
    str += "CALSCALE:GREGORIAN" + lt;
    for (let i = 0; i < vEventsArr.length; i++) {
        str += vEventsArr[i].trim() + lt;
    }
    str += "END:VCALENDAR";
    return str;
}

function exportICSCalendar() {
    let eventsArr = makeVEventsArr(calendarDatabase["data"]);
    let cal = makeVCalendar(eventsArr);
    copyAndSaveString(cal, "ICSCalendar" + getTodaysDate(), ".ics", "text/calendar");
}

function removeDuplicateContacts() {
    let contacts=contactsTable["data"];
    let contactsStringified=[];
    //make stringified version of contact objects
    for (let i=0;i<contacts.length;i++){
        console.log(contacts[i]);
        contactsStringified[i]=JSON.stringify(contacts[i]);
    }
    //make a new array of strings, skip duplicates
    let tempArr=[];
    for (let i=0;i<contactsStringified.length;i++){
        if (tempArr.includes(contactsStringified[i])){
            //do nothing, this is a duplicate
        }
        else{
            tempArr.push(contactsStringified[i]);
        }
    }
    let tempArr2=[];
    //convert array of strings to array of objects
    for (let i=0;i<tempArr.length;i++){
        tempArr2.push(JSON.parse(tempArr[i]));
    }
    //"deep copy" contacts data to array of objects
    contactsTable["data"]=JSON.parse(JSON.stringify(tempArr2));
    //rewrite contacts table
    contactsTableElement.innerHTML = buildContactsTableElement(contactsTable);
}

//  ------------notes --------------------
let noteFontSize = 2.5 / 3.0;
let note = document.getElementById('note');
note.value = "";
let compareNoteValue = "";

initializeNotesApp();

function initializeNotesApp() {
    note.style.fontSize = noteFontSize.toString() + "rem";
    note.spellcheck = false;
    note.focus();
}


function changeFontSize(fontButton) {
    let doThis = fontButton.innerHTML;
    if (doThis === "-") {
        if (noteFontSize > 0.2) {
            noteFontSize -= 0.2; //no need to go less than 0.2rem
        }
    } else {
        noteFontSize += 0.2;
    }
    note.style.fontSize = noteFontSize.toString() + "rem";
}

function newNotesEntry() {
    if (note.value != '') {
        if (confirm("This will erase current contents.")) {
            note.value = '';
            compareNoteValue = '';
        }
    }
}

function notesLoad() {
    let fileContents = "";
    let inputTypeIsFile = document.createElement('input');
    inputTypeIsFile.type = "file";
    inputTypeIsFile.accept = ".txt";
    inputTypeIsFile.addEventListener("change", function () {
        let inputFile = inputTypeIsFile.files[0];
        let fileReader = new FileReader();
        fileReader.onload = function (fileLoadedEvent) {
            fileContents = fileLoadedEvent.target.result;
            note.value = fileContents;
        };
        fileReader.readAsText(inputFile, "UTF-8");
    });
    inputTypeIsFile.click();
}

function notesSave() {
    basename = "notes" + getTodaysDate();
    copyAndSaveString(note.value, basename, ".txt");
}

function printNotesDiv(id) {
    let a = window.open();
    a.document.write(serializeNotesElementToPage(id, "html{background-color:white;}#note{font-size:" + noteFontSize + "rem}"));
    a.document.close();
    a.print();
}

function serializeNotesElementToPage(id, extraStyle = "") {
    let boilerPlate1 = "<!DOCTYPE html><html lang='en'><head><meta charset='UTF-8'><meta http-equiv='X-UA-Compatible' content='IE=edge'><meta name='viewport' content='width=device-width, initial-scale=1.0'><title></title><style>";

    let allStyleTags = document.getElementsByTagName('style');

    let styleElementContent = "";
    for (let i = 0; i < allStyleTags.length; i++) {
        styleElementContent = allStyleTags[i].innerHTML;
    }

    styleElementContent += "pre{white-space: pre-wrap;overflow-wrap: break-word;margin: 0;padding: 0;}"
    let boilerPlate2 = "</style></head><body>";
    let boilerPlate3 = "</body></html>";
    let str = "<pre id='note'>" + document.getElementById(id).value + "</pre>";
    let htmlPage = boilerPlate1 + styleElementContent + extraStyle + boilerPlate2 + str + boilerPlate3;
    console.log(htmlPage);
    return htmlPage;
}

note.addEventListener('keydown', function (evt) {
    //https://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea
    //https://stackoverflow.com/users/819732/kasdega
    if (evt.key == 'Tab') {
        evt.preventDefault();
        let start = note.selectionStart;
        let end = note.selectionEnd;
        note.value = note.value.substring(0, start) +
            "\t" + note.value.substring(end);
        note.selectionStart =
            note.selectionEnd = start + 1;
    }
});
// WRITE
let textarea = document.getElementById("text-editor");
let documentDiv = document.getElementById('document-result');
let remSize = 1;
let marginSize = 2;
let writeUndos = [];
let writeUndosCursor = 0;
let compareWriteData = "";

initializeWriteApp();

let lastTextAreaText = textarea.value;

function initializeWriteApp() {
    documentDiv.style.fontSize = remSize + "rem";
    documentDiv.style.marginLeft = marginSize + "rem";
    documentDiv.style.marginRight = marginSize + "rem";
    writeUndos.push(textarea.value);
    writeUpdateResult();
    textarea.spellcheck = false;
    textarea.focus(); //ensures spellcheck update

    document.getElementById('text-editor').addEventListener('keydown', function(e) {
        //https://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea
        //https://stackoverflow.com/users/819732/kasdega
        //console.log(this);
        if (e.key == 'Tab') {
            e.preventDefault();
            insertTab(this);
            updateUndosIfTextChanges();
        }
    });

    document.getElementById('text-editor').addEventListener('input', updateUndosIfTextChanges); //catching key inputs
    compareWriteData = makeCompareWriteData();
}

function updateUndosIfTextChanges() {
    console.log("called");
    console.log(writeUndos);
    if (lastTextAreaText != textarea.value) {
        addUndo();
        lastTextAreaText = textarea.value;
    }
    console.log(writeUndos);

}

function insertTab(aTextarea) {
    let start = aTextarea.selectionStart;
    let end = aTextarea.selectionEnd;
    // set textarea value to: text before caret + tab + text after caret
    aTextarea.value = aTextarea.value.substring(0, start) +
        //"    " + this.value.substring(end); using 4 spaces
        "\t" + aTextarea.value.substring(end);
    // put caret at right position again
    aTextarea.selectionStart =
        //aTextarea.selectionEnd = start + 4; using 4 spaces
        aTextarea.selectionEnd = start + 1;
    writeUpdateResult();
}

//Script to print the content of a div
function exportToHTML() {
    let contents = serializeElementToPage("document-parent", "html,#document-result,#document-parent{background-color:white;}");
    copyToClipBoard(contents);
    if (confirm("HTML document exported to clipboard.\n\nWould you like to export to HTML file?")) {
        saveStringToTextFile(contents, 'write' + getTodaysDate(), '.html');
    }
}

function newDocument() {
    if (confirm("This will overwrite current document.")) {
        writeResetAll();
    }
}

function writeResetAll() {
    //reset global variables;
    writeBaseFilename = "";
    remSize = 1;
    marginSize = 2;

    //reset text area value
    textarea.value = "";

    //reapply base styles to the div
    documentDiv.style.textAlign = "left";
    documentDiv.style.fontFamily = "Georgia, 'Times New Roman', Garamond, Times, serif";
    documentDiv.style.fontSize = "1rem";
    documentDiv.style.marginLeft = "2rem";
    textarea.spellcheck = false;

    //reset undo array
    writeUndos = [];
    writeUndos.push(textarea.value);

    //redisplay new result
    writeUpdateResult();

    //set focus to textarea
    textarea.focus(); //ensures spell check is refreshed

}

function makeCompareWriteData() {
    writeUpdateResult();
    let data = {}
    data["text"] = textarea.value;
    data["textAlign"] = documentDiv.style.textAlign;
    data["fontFamily"] = documentDiv.style.fontFamily;
    data["fontSize"] = documentDiv.style.fontSize;
    data["marginSize"] = documentDiv.style.marginLeft;
    data["spellCheck"] = textarea.spellcheck;
    return JSON.stringify(data);;
}

function writeDataToJSON() {
    writeUpdateResult();
    let data = {}
    data["text"] = textarea.value;
    data["textAlign"] = documentDiv.style.textAlign;
    data["fontFamily"] = documentDiv.style.fontFamily;
    data["fontSize"] = documentDiv.style.fontSize;
    data["marginSize"] = documentDiv.style.marginLeft;
    data["spellCheck"] = textarea.spellcheck;
    //if (writeBaseFilename === "") {
    writeBaseFilename = "write" + getTodaysDate();
    //};
    let saveContents = JSON.stringify(data);
    saveStringToTextFile(saveContents, writeBaseFilename, ".json");
    compareWriteData = makeCompareWriteData();
}

function writeLoad() {
    console.log("writeLoad() called");
    console.log(textarea.value);
    console.log(textarea.value.length);
    let proceed = true;
    if (textarea.value.length != 0) {
        proceed = confirm("This will overwrite current document");
    }
    if (proceed) {
        let fileContents = "";
        let inputTypeIsFile = document.createElement('input');
        inputTypeIsFile.type = "file";
        inputTypeIsFile.accept = ".json";
        inputTypeIsFile.addEventListener("change", function() {
            let inputFile = inputTypeIsFile.files[0];
            let fileReader = new FileReader();
            fileReader.onload = function(fileLoadedEvent) {
                fileContents = fileLoadedEvent.target.result;
                let loadedData = JSON.parse(fileContents);
                textarea.value = loadedData["text"];
                documentDiv.style.textAlign = loadedData["textAlign"];
                documentDiv.style.fontFamily = loadedData["fontFamily"];
                documentDiv.style.fontSize = loadedData["fontSize"];
                documentDiv.style.marginLeft = loadedData["marginSize"];
                textarea.spellcheck = loadedData["spellCheck"];
                writeUpdateResult();
                remSize = parseFloat(loadedData["fontSize"].split("rem")[0]);
                marginSize = parseFloat(loadedData["marginSize"].split("rem")[0]);
                writeUndos = [];
                console.log("writeUndos length", writeUndos.length);
                writeUndos.push(textarea.value);
                textarea.focus(); //ensures spell check is refreshed

            };

            fileReader.readAsText(inputFile, "UTF-8");
        });
        inputTypeIsFile.click();
    }
    //}

}


function addUndo() { //moving "foward", check to see if cursor is at end or not

    console.log(writeUndos.length, writeUndosCursor);
    console.log(writeUndos);
    if (writeUndos.length - 1 === writeUndosCursor) {
        console.log("we are at end");
        if (writeUndos.length >= 316) { //316 levels of undo
            writeUndos.shift();
            writeUndos.push(textarea.value);
        } else {
            writeUndos.push(textarea.value);
            writeUndosCursor += 1;

            //  a   b   c   d   e
            //  0   1   2   3   4
            //          ^
            //  ---keep---  xxxxx
            //  
            //use slice(0,-2)
            //
            //  -2 is the length - (cursor + 1)
            //               5   -    3

        }
        console.log(writeUndos);
    } else {
        console.log("we are not at end");
        console.log(writeUndos);
        let removeNumberOfElements = writeUndos.length - (writeUndosCursor + 1);
        writeUndos = writeUndos.slice(0, -removeNumberOfElements);
        console.log(writeUndos);
        //remove everything past the cursor
        //then push new value

        writeUndos.push(textarea.value);
        writeUndosCursor += 1;

        console.log(writeUndos);
    }
}

function backUndo() { //this is just undo
    console.log("back Undo called");
    console.log(writeUndos);
    console.log(writeUndosCursor);
    //if (writeUndos.length > 1) {
    if (writeUndosCursor > 0) {
        //let thisText = writeUndos.pop();
        let thisText = writeUndos[writeUndosCursor - 1];
        textarea.value = thisText;
        writeUpdateResult();
        writeUndosCursor = writeUndosCursor - 1;
    }
    console.log(writeUndos);
    console.log(writeUndosCursor);
}

function writeRedo() {
    console.log("redo called");
    // if we are at end do nothing, otherwise advance
    if (writeUndos.length - 1 === writeUndosCursor) {
        console.log("we are at end");
    } else {
        console.log("we are not at end");
        writeUndosCursor += 1;

        let thisText = writeUndos[writeUndosCursor];
        textarea.value = thisText;
        writeUpdateResult();

    }
}

function processSelectedText(clickedElement) {
    let action = clickedElement.innerHTML;
    console.log(action);
    // if (action != "⟲") {
    //     addUndo();
    // }

    if (action === "⇚") { //align left
        documentDiv.style.textAlign = "left";
    } else if (action === "⇛⇚") { //align center
        documentDiv.style.textAlign = "center";
    } else if (action === "⇛") { //align right
        documentDiv.style.textAlign = "right";
    } else if (action === "Mono") {
        documentDiv.style.fontFamily = "'Courier New', Courier, monospace";
    } else if (action === "Serif") {
        documentDiv.style.fontFamily = "Georgia, 'Times New Roman', Garamond, Times, serif";
    } else if (action === "Sans") {
        documentDiv.style.fontFamily = "Arial, Verdana, Helvetica, Tahoma, sans-serif";
    } else if (action === "<sub>A</sub>A") {
        remSize = remSize + .2;
        documentDiv.style.fontSize = remSize.toString() + "rem";
    } else if (action === "<sup>A</sup>A") {
        remSize = remSize - .2;
        documentDiv.style.fontSize = remSize.toString() + "rem";
    } else if (action === "⇥⇤") { //increase margins
        marginSize = marginSize + 1;
        if (marginSize > 20) {
            marginSize = 20;
        }
        documentDiv.style.marginLeft = marginSize.toString() + "rem";
        documentDiv.style.marginRight = marginSize.toString() + "rem";

    } else if (action === "⇤⇥") { //decrease margins
        marginSize = marginSize - 1;
        if (marginSize < 0) {
            marginSize = 0;
        }
        documentDiv.style.marginLeft = marginSize.toString() + "rem";
        documentDiv.style.marginRight = marginSize.toString() + "rem";
    } else if (action === "⟲") {

        backUndo();
        //console.log("undo called");


    } else if (action === "✓") {
        console.log(textarea.spellcheck);
        textarea.spellcheck = !(textarea.spellcheck);
        console.log(textarea.spellcheck);
        textarea.focus();
        //textarea.blur();
    }
    // else if (action === "↹") {
    //     //alert("tab called");
    //     insertTab(textarea);
    //     return;
    // }

    let len = textarea.value.length;
    let start = textarea.selectionStart;
    let end = textarea.selectionEnd;
    let sel = textarea.value.substring(start, end);

    // This is the selected text and alert it
    //alert(sel);

    let replace = sel;

    if (action === "<b>B</b>") {
        replace = '<b>' + sel + '</b>';
    } else if (action === "<u>U</u>") {
        replace = '<u>' + sel + '</u>';
    } else if (action === "<em>I</em>") {
        replace = '<em>' + sel + '</em>';
    } else if (action === "H1") {
        replace = '<h1>' + sel + '</h1>';
    } else if (action === "H2") {
        replace = '<h2>' + sel + '</h2>';
    } else if (action === "H3") {
        replace = '<h3>' + sel + '</h3>';
    } else if (action === "¶") {
        replace = '<p>' + sel + '</p>';
    } else if (action === "―") {
        replace = '<hr>' + sel;
    } else if (action === "•") {
        replace = '&bullet; ' + sel;
    } else if (action === "↹") {
        replace = "\t" + sel;
    }
    // Here we are replacing the selected text with this one
    textarea.value = textarea.value.substring(0, start) + replace + textarea.value.substring(end, len);
    writeUpdateResult();
    textarea.selectionStart = start + replace.length;
    textarea.selectionEnd = start + replace.length;
    textarea.focus();
    if (action != "⟲") {
        //addUndo();
        updateUndosIfTextChanges();
    }
}

function writeUpdateResult() {
    let currentContents = document.getElementById('text-editor').value;
    //console.dir(document.getElementById('text-editor'));
    //console.log(currentContents);
    document.getElementById('document-result').innerHTML = currentContents.split('\n').join('<br>');
    if (textarea.spellcheck === true) {
        document.getElementById("spell-check").style.color = "green";
    } else {
        document.getElementById("spell-check").style.color = "red";
    }
}

function printDiv(id){
    let mySerializer= new XMLSerializer(id);
    let s = new XMLSerializer();
    let d = document;
    let str = s.serializeToString(d.getElementById(id));
    //var divContents = document.getElementById("GFG").innerHTML;
    var a = window.open('', '');
    a.document.write('<html>');
    a.document.write("<style> #document-result {overflow-wrap: break-word;width: auto;white-space: pre-wrap;} </style>");
    //a.document.write('<body > <h1>Div contents are <br>');
    a.document.write(str);
    a.document.write('</body></html>');
    a.document.close();
    a.print();
}//---tables----
let tableElement = document.getElementById('tables-table');
let tablesTable = {
    "name": "Table",
    "headers": ["Column 1", "Column 2", "Column 3"],
    "data": [
        { "Column 1": "", "Column 2": "", "Column 3": "" },
        { "Column 1": "", "Column 2": "", "Column 3": "" },
        { "Column 1": "", "Column 2": "", "Column 3": "" }
    ]
}

// let compareTablesTable = JSON.stringify(tablesTable);
// let initialTablesTable = compareTablesTable;
let initialTablesTable = JSON.stringify(tablesTable);
initializeTablesApp();


//////////TABLES//////////
function showTablesDiv(id) {
    //console.log("show mains called with " + id);
    updateDataFromCurrentInputs(tablesTable);

    let divs = document.getElementsByClassName('tables-div');
    for (let div of divs) {
        div.style.display = "none";
    }
    document.getElementById(id).style.display = "unset";
    // document.getElementById(id).style.flexDirection="column";
}



function initializeTablesApp() {
    makeTable(JSON.parse(initialTablesTable));
    updateDataFromCurrentInputs(tablesTable);
    showTablesDiv('tables-tables-table');
}

function backupTablesTable() {
    updateDataFromCurrentInputs(tablesTable);
    return JSON.parse(JSON.stringify(currentTablesTable));
}

function processColumnClick(header) {
    updateDataFromCurrentInputs(tablesTable);
    populateMoveColumnSelect(tablesTable);
    document.getElementById("tables-current-header").innerHTML = header;
    document.getElementById("tables-new-header-name").value = header;
    showTablesDiv("tables-tables-header-form");
}

function processRowClick(row) {
    updateDataFromCurrentInputs(tablesTable);
    populateMoveRowSelect(tablesTable);
    document.getElementById("tables-current-row").innerHTML = row.toString();
    showTablesDiv("tables-tables-row-form");
}

function makeTable(table) {
    //let tableElement = document.getElementById('tables-table');
    let str = "";

    //fill in header from object
    str = "";
    let headers = table["headers"]; //an array of strings
    str += "<thead><tr><th></th>";
    for (let i = 0; i < headers.length; i++) {
        str += "<th id='" + headers[i] + "' onclick=\"processColumnClick('" + headers[i] + "');\">" + headers[i].replace(/</g, "&lt;").replace(/>/g, "&gt;"); + "</th>";
    }
    str += "<th id='add-column' onclick='addColumn(tablesTable)'>+</th>";
    str += "</tr></thead>";
    let tableHeader = str;

    //fill in body data from object
    str = "<tbody>";
    let bodyData = table.data; //an array of objects;
    console.log("bodyData");
    console.log(bodyData);
    let rowCount = bodyData.length;
    for (let i = 0; i < rowCount; i++) {
        str += "<tr><td class='tables-table-row-number' onclick='processRowClick(" + i.toString() + ")'>" + i.toString() + "</td>";
        let columnCount = headers.length;
        console.log(columnCount);
        for (let j = 0; j < columnCount; j++) {
            //console.log(headers[j]);
            //console.log(bodyData[i][headers[j]]);
            if (bodyData[i][headers[j]] === undefined) {
                bodyData[i][headers[j]] = "input read error";
            }
            str += "<td><input type='text' id='cell-" + i.toString() + "-" + j.toString() + "' value='" + bodyData[i][headers[j]].toString() + "'></td>";
            //str += "<td><input type='text' id='cell-" + (i + 1).toString() + "-" + (j + 1).toString() + "' value='" + i.toString()+j.toString() + "'></td>";
        }
        str += "</tr>";
    }
    str += "</tbody>"
    let tableBody = str;

    //make footer for additional controls
    str = "<tfoot><tr><th id='add-row' onclick='addRow(tablesTable)'>+</th>";
    for (let i = 0; i < headers.length; i++) {
        str += "<th id='footer-" + (i + 1).toString() + "' onclick=\"processColumnClick('" + headers[i] + "');\"></th>";
    }
    str += "</tr></tfoot>";
    let tableFooter = str;
    let strTable = tableHeader + tableBody + tableFooter;

    //addListenersToTable();
    populateMoveColumnSelect(table);
    populateMoveRowSelect(table);

    tableElement.innerHTML = strTable;

    return strTable;
}


function populateMoveColumnSelect(table) {
    let moveColumnSelect = document.getElementById('move-column');
    moveColumnSelect.options.length = 0;
    // moveColumnSelect.style.backgroundColor = "orange";
    let currentTableHeaders = table.headers; //an array of header names
    for (th of currentTableHeaders) {
        let option = document.createElement('option');
        option.value = th;
        option.text = th;
        moveColumnSelect.add(option);
    }
}

function populateMoveRowSelect(table) {
    // document.getElementById(selectbox).options.length = 0;
    let moveRowSelect = document.getElementById('move-row');
    moveRowSelect.options.length = 0;
    // moveRowSelect.style.backgroundColor = 'orange';
    for (let i = 0; i < table["data"].length; i++) {
        let option = document.createElement('option');
        option.value = i.toString();
        option.text = i.toString();
        moveRowSelect.add(option);
    }
}

function updateDataFromCurrentInputs(table) {
    let headers = table["headers"];
    console.log("headers");
    console.log(headers);
    for (let i = 0; i < table.data.length; i++) {
        for (let j = 0; j < table.headers.length; j++) {
            let id = "cell-" + i.toString() + "-" + j.toString();
            let thisCell = document.getElementById(id);
            table.data[i][headers[j]] = thisCell.value;
        }
    }
}
//Column functions
function updateHeaderName() {
    //let table = tablesTable;
    //get old name
    let fieldName = document.getElementById("tables-current-header").innerHTML;
    //get new name
    let newName = document.getElementById('tables-new-header-name').value;

    //do nothing if they are the same
    if (fieldName === newName) {
        makeTable(tablesTable);
        return;
    }
    if (newName === "") { //if blank make new
        newName = prompt("There is no name listed, please enter the new name");
        if (newName === null) {
            return;
        }
    }

    //newName = newName.replace(/</g, "&lt;").replace(/>/g, "&gt;");

    tablesTable = _changeHeaderAndDataPropertyName(tablesTable, newName, fieldName);

    makeTable(tablesTable);
    showTablesDiv('tables-tables-table');
}

function tablesSort(direction) {
    let field = document.getElementById("tables-current-header").innerHTML;
    sortTablesByField(field, direction);

}

function sortTablesByField(field, direction = 1) {
    if (confirm("Sort by " + field + "?\n\nThis is destructive and irreversible.")) {
        destructiveSort(tablesTable["data"], field, direction);
        makeTable(tablesTable);
        showTablesDiv('tables-tables-table');
    }
}

function _changeHeaderAndDataPropertyName(table, newName, oldName) {
    let data = table["data"];
    newName = getBestName(table, newName);
    let index = table["headers"].indexOf(oldName); //get index of field 
    table["headers"][index] = newName; //change header name
    //update rows
    for (let i = 0; i < data.length; i++) {
        data[i][newName] = data[i][oldName]; //set new property to old
        delete data[i][oldName]; //delete old
    }
    return table;
}


function deleteColumn() {
    let columnName = document.getElementById("tables-current-header").innerHTML;
    if (confirm("Are you sure? \n\nDelete Column: " + columnName + "?")) {
        let index = tablesTable["headers"].indexOf(columnName);
        tablesTable["headers"].splice(index, 1); //delete from header array
        //loop through rows
        for (let i = 0; i < tablesTable["data"].length; i++) {
            delete tablesTable["data"][i][columnName];
        }
        makeTable(tablesTable);
        showTablesDiv('tables-tables-table');
    }
}

function addColumn(table) {
    //alert("need to process add column");
    updateDataFromCurrentInputs(table);
    let newIndex = 1;
    let newColumnName = "new" + newIndex.toString(); //make a new name

    //if name already in use, make a new name
    while (table["headers"].includes(newColumnName)) {
        console.log("column name already in use");
        newIndex += 1;
        newColumnName = "new" + newIndex.toString();
    }

    table.headers.push(newColumnName);

    fillInEmptyPropertyValues(table);
    makeTable(table);
}

function moveColumn() {
    let columnName = document.getElementById("tables-current-header").innerHTML;
    let destinationColumnName = document.getElementById("move-column").value;
    if (columnName === destinationColumnName) {
        console.log("destination is same as source");
        return;
    }
    let index = tablesTable["headers"].indexOf(columnName);
    let destinationIndex = tablesTable["headers"].indexOf(destinationColumnName);
    let headerToMove = tablesTable["headers"].splice(index, 1)[0]; //splice returns an array length 1
    tablesTable["headers"].splice(destinationIndex, 0, headerToMove);
    makeTable(tablesTable);
    showTablesDiv('tables-tables-table');
}

function getBestName(table, name) { //if header name taken, returns similar name
    let headers = table["headers"];
    let nameCount = 0;
    let bestName = name;
    while (headers.includes(bestName)) {
        console.log("column name already in use");
        nameCount += 1;
        bestName = name + "-" + nameCount.toString();
    }
    return bestName;
}

function copyColumn() {
    //get column 
    let columnName = document.getElementById("tables-current-header").innerHTML;

    //make name for new column
    let newName = getBestName(tablesTable, columnName);

    //add to headers			
    tablesTable["headers"].push(newName);

    //go through rows of data
    for (let i = 0; i < tablesTable["data"].length; i++) {
        tablesTable["data"][i][newName] = tablesTable["data"][i][columnName];
    }

    makeTable(tablesTable);
    showTablesDiv('tables-tables-table');
}

function calculateTotal() {
    //get column 
    let columnName = document.getElementById("tables-current-header").innerHTML;

    let total = 0;
    for (let row of tablesTable.data) {
        total = total + Number(row[columnName]);
    }
    if (confirm("The total is: " + total.toString() + "\nCopy to clipboard?")) {
        copyToClipBoard(total.toString());
    };
    showTablesDiv('tables-tables-table');
}

function tablesCancel() {
    console.log("tablesCancel called");
    makeTable(tablesTable); //probably not needed
    showTablesDiv('tables-tables-table');

}

function calculateAverage() {
    alert("calculate average called");
    console.log("calcualtoe average called");

    let columnName = document.getElementById("tables-current-header").innerHTML;

    let total = 0;

    for (let row of tablesTable.data) {
        total = total + Number(row[columnName]);
    }

    let average = total / tablesTable.data.length;

    if (confirm("The average is: " + average.toString() + "\nCopy to clipboard?")) {
        copyToClipBoard(average.toString());
    }
    showTablesDiv('tables-tables-table');
}

//row functions
function addRow(table) {
    let headers = table["headers"];
    updateDataFromCurrentInputs(table);
    let numberOfColumns = table.headers.length;
    let tempRow = {};
    for (let i = 0; i < numberOfColumns; i++) {
        tempRow[headers[i]] = "";
    }
    table["data"].push(tempRow);
    makeTable(table);
}

function deleteRow() {
    let index = parseInt(document.getElementById("tables-current-row").innerHTML);
    let data = tablesTable["data"];
    data.splice(index, 1);
    makeTable(tablesTable);
    showTablesDiv('tables-tables-table');
}

function copyRow() {
    console.log("copy row called");
    let index = parseInt(document.getElementById("tables-current-row").innerHTML);
    let data = tablesTable["data"];
    console.log(data);
    let rowToCopy = JSON.parse(JSON.stringify(tablesTable.data[index]));
    data.push(rowToCopy);
    makeTable(tablesTable);
    showTablesDiv('tables-tables-table');
}

function moveRow() {
    console.log("move row called");
    let index = parseInt(document.getElementById("tables-current-row").innerHTML);
    let data = tablesTable["data"];
    let destinationIndex = parseInt(document.getElementById("move-row").value);
    let rowToMove = data.splice(index, 1)[0];
    data.splice(destinationIndex, 0, rowToMove);
    makeTable(tablesTable);
    showTablesDiv('tables-tables-table');
}


function tablesNewTable() {
    if (confirm("Are you sure?  This will erase all current data.")) {
        initializeTablesApp();
    }
}

function tablesLoad() {
    console.log("tablesLoad() called");
    let fileContents = "";
    let inputTypeIsFile = document.createElement('input');
    inputTypeIsFile.type = "file";
    inputTypeIsFile.accept = ".csv";
    inputTypeIsFile.addEventListener("change", function() {
        let inputFile = inputTypeIsFile.files[0];
        let fileReader = new FileReader();
        fileReader.onload = function(fileLoadedEvent) {
            fileContents = fileLoadedEvent.target.result;
            if (confirm("Use the first line as the header row?")) {
                //tablesTable = readCSV(fileContents, true);
                tablesTable=csvToJSON(fileContents, true);
            } else {
                //tablesTable = readCSV(fileContents, false);
                tablesTable=csvToJSON(fileContents, true);
            }
            makeTable(tablesTable);
            // compareTablesTable = JSON.stringify(tablesTable);
        };
        fileReader.readAsText(inputFile, "UTF-8");
    });
    inputTypeIsFile.click();
}

function tablesSave() {
    console.log("tablesSave() called");
    updateDataFromCurrentInputs(tablesTable);

    if (confirm("Include header as first line in csv file?")) {
        saveStringToTextFile(makeCSV(tablesTable, true), "csvTable" + getTodaysDate(), ".csv");
    } else {
        saveStringToTextFile(makeCSV(tablesTable, false), "csvTable" + getTodaysDate(), ".csv");
    }
    // compareTablesTable = JSON.stringify(tablesTable);
}

// function tablesShowRules() {
//     alert('FORMATTING RULES:\n\nWhen Saving:\n1) All cells are quoted text.\n2) Interior double quotes in cells are converted like this: "->""\n\nIf loading CSV from other apps:\n1) Cells should all be text type.\n2) Quote all text strings when saving.')
// }

function tablesCopyCSVToClipboard() {
    updateDataFromCurrentInputs(tablesTable);
    let thisResult = "";
    if (confirm("Include header as first line?")) {
        thisResult = copyToClipBoard(makeCSV(tablesTable, true));
    } else {
        thisResult = copyToClipBoard(makeCSV(tablesTable, false));
    }
    return thisResult;
}let calcInput = document.getElementById('calculator-input');
document.getElementById("clear-calc").addEventListener("click", clearCalc);
document.getElementById("remove-last-char").addEventListener("click", removeLastChar);
document.getElementById("equals-button").addEventListener("click", evaluateCalculatorInput);
let theseCalculatorButtons = document.getElementsByClassName('build-calc-string');
for (let calculatorButton of theseCalculatorButtons) {
    calculatorButton.addEventListener("click", () => { buildCalcString(calculatorButton.innerHTML) });
}

function buildCalcString(str) {
    calcInput.value += str;
}

function clearCalc() {
    calcInput.value = "";
}

function removeLastChar() {
    calcInput.value = calcInput.value.slice(0, -1);
}

function evaluateCalculatorInput() {
    let sanitizedValue = calcInput.value.replace(/[^-+/*\de.]/g, '');
    if (sanitizedValue != calcInput.value) {
        alert("Unallowed characters replaced with empty space during evaluation.");
    }
    document.getElementById('last-calculator-expression').innerHTML = "Evaluated: " + sanitizedValue;
    let result = '';
    try {
        // result = eval(sanitizedValue);
        result = evalReplaceFunction(sanitizedValue);
    } catch (error) {
        result = error;
    }
    calcInput.value = result;
}

function evalReplaceFunction(str) {
    return Function("'use strict'; return (" + str + ")")();
}
let nestedMenues = document.getElementsByClassName("nested-menu");
for (let nestedmenu of nestedMenues) {
    nestedmenu.addEventListener("click", (evt) => { toggleNest(evt.target) });
}

function toggleNest(menu) {
    let siblings = menu.parentElement.children;
    for (let sibling of siblings) {
        if (sibling === menu) {
            //alert("found self!");
        } else {
            if (sibling.style.display === "none") {
                sibling.style.display = "inherit";
            } else {
                sibling.style.display = "none";
            }
        }
    }
}

function toggleAll() {
    for (let nestedmenu of nestedMenues) {
        toggleNest(nestedmenu)
    }
}

function openSelectedInitialNests() {
    for (let nestedmenu of nestedMenues) {
        if (nestedmenu.classList.contains("initial-open")) {
            toggleNest(nestedmenu);
        }
    }
}

toggleAll();
openSelectedInitialNests();</script><script>let selfString="";
function createSelf(){
    let html=document.getElementsByTagName("html")[0].innerHTML;
    selfString+="<!DOCTYPE html><html lang='en'>"+html+"</html>";
}
window.onload=createSelf();makeFavicon("p", "white", "mediumblue");
window.onbeforeunload = askConfirm;
showPlannerDiv('planner-load');
showMain('main-planner');</script></body>
</html>